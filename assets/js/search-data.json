{
  
    
        "post0": {
            "title": "Chapitre 6 : La programmation orientée objet",
            "content": "Comme vous l&#39;avez vu dans les premiers exemples de code de ce cours, il n&#39;est pas obligatoire d&#39;organiser votre code en classes lorsque vous programmez en Python. Vous pouvez utiliser les fonctions par elles-mêmes, dans ce qu&#39;on appelle une approche de programmation procédurale. Cependant, alors qu&#39;un style procédural peut suffire pour écrire des programmes courts et simples, une approche de programmation orientée objet (POO) devient plus précieuse à mesure que votre programme augmente en taille et en complexité. . Plus votre code contient de données et de fonctions, plus il est important de les organiser en sous-groupes logiques, en veillant à ce que les données et fonctions liées soient regroupées et que les données et fonctions non liées n&#39;interfèrent pas les unes avec les autres. Le code modulaire est plus facile à comprendre et à modifier, et se prête davantage à la réutilisation et la réutilisation du code est précieuse car elle réduit le temps de développement. . Principes de base de la POO . L&#39;encapsulation . Le principe le plus important de l&#39;orientation objet est l&#39;encapsulation : l&#39;idée que les données à l&#39;intérieur de l&#39;objet ne doivent être accessibles que via une interface publique, c&#39;est-à-dire les méthodes de l&#39;objet. . La fonction age que nous avons vue dans le chapitre précédent est un bon exemple de cette philosophie. Si nous voulons utiliser les données stockées dans un objet pour effectuer une action ou calculer une valeur dérivée, nous définissons une méthode associée à l&#39;objet qui le fait. Ensuite, chaque fois que nous voulons effectuer cette action, nous appelons la méthode sur l&#39;objet. Nous considérons comme une mauvaise pratique de récupérer les informations à l&#39;intérieur de l&#39;objet et d&#39;écrire un code séparé pour effectuer l&#39;action à l&#39;extérieur de l&#39;objet. . L&#39;encapsulation est une bonne chose pour plusieurs raisons : . La fonctionnalité est définie à un seul endroit et non à plusieurs endroits. | Cette dernière est défini dans un endroit logique, l&#39;endroit où les données sont conservées. | Les données à l&#39;intérieur de notre objet ne sont pas modifiées de manière inattendue par un code externe dans une partie complètement différente de notre programme. | Lorsque nous utilisons une méthode, nous avons seulement besoin de savoir quel résultat la méthode produira, nous n&#39;avons pas besoin de connaître les détails sur les éléments internes de l&#39;objet pour l&#39;utiliser. Nous pourrions passer à l&#39;utilisation d&#39;un autre objet qui est complètement différent à l&#39;intérieur, et ne pas avoir à changer de code car les deux objets ont la même interface. | . On peut dire que l&#39;objet « sait comment » faire des choses avec ses propres données, et c&#39;est une mauvaise idée pour nous d&#39;accéder à ses données internes et de faire nous-mêmes des choses avec. . En Python, l&#39;encapsulation n&#39;est pas imposée par le langage, mais il existe une convention que nous pouvons utiliser pour indiquer qu&#39;une propriété est destinée à être privée et ne fait pas partie de l&#39;interface publique de l&#39;objet : nous commençons son nom par un trait de soulignement : . class Student: def __init__(self, name): # Name must be considered as a private property self._name = name . La Composition .",
            "url": "https://axi-technologies.github.io/AXI-Fastpages/python-intro-gen/chapter/6/lesson/2/",
            "relUrl": "/python-intro-gen/chapter/6/lesson/2/",
            "date": " • Jan 2, 2022"
        }
        
    
  
    
        ,"post1": {
            "title": "Chapitre 6 : Les classes et objets en python",
            "content": "Nous avons déjà vu comment nous pouvons utiliser un dictionnaire pour regrouper des données associées et comment nous pouvons utiliser des fonctions pour créer des raccourcis pour des groupes d&#39;instructions couramment utilisés. Une fonction exécute une action en utilisant un ensemble de paramètres d&#39;entrée. Toutes les fonctions ne sont pas applicables à tous les types de données. Les classes sont un moyen de regrouper des données et des fonctions connexes qui agissent sur ces données. . Une classe est un type de données, tout comme une string, un entier ou une liste. Lorsque nous créons un objet de ce type de données, nous l&#39;appelons une instance d&#39;une classe. . Comme nous l&#39;avons déjà mentionné, dans certains autres langages, certaines entités sont des objets et d&#39;autres non. En Python, tout est objet, tout est une instance d&#39;une certaine classe. Les classes et les types sont eux-mêmes des objets, et ils sont de type type. Vous pouvez connaître le type de n&#39;importe quel objet à l&#39;aide de la fonction type : . type(42) . Les valeurs de données que nous stockons à l&#39;intérieur d&#39;un objet sont appelées attributs et les fonctions associées à l&#39;objet sont appelées méthodes. Nous avons déjà utilisé les méthodes de certains objets intégrés, comme les string et les listes. . Lorsque nous concevons nos propres objets, nous devons décider comment nous allons regrouper les choses et ce que nos objets vont représenter. . Parfois, nous écrivons des objets qui correspondent très intuitivement aux choses du monde réel. Par exemple, si nous écrivons du code pour simuler des réactions chimiques, nous pourrions avoir des objets Atom que nous pouvons combiner pour créer un objet Molécule. Cependant, il n&#39;est pas toujours nécessaire, souhaitable ou même possible de rendre tous les objets de code parfaitement analogues à leurs homologues du monde réel. . Parfois, nous pouvons créer des objets qui n&#39;ont aucun équivalent dans le monde réel, simplement parce qu&#39;il est utile de regrouper certaines fonctions. . 1. Cr&#233;ation d&#39;une classe (class) . Voici un exemple de classe personnalisée simple qui stocke des informations sur une personne : . import datetime # we will use this for date objects class Person: def __init__(self, name, surname, birthdate, address, telephone, email): self.name = name self.surname = surname self.birthdate = birthdate self.address = address self.telephone = telephone self.email = email def age(self): today = datetime.date.today() age = today.year - self.birthdate.year if today &lt; datetime.date(today.year, self.birthdate.month, self.birthdate.day): age -= 1 return age person = Person( &quot;Jane&quot;, &quot;Doe&quot;, datetime.date(1992, 3, 12), # year, month, day &quot;No. 12 Short Street, Greenville&quot;, &quot;555 456 0987&quot;, &quot;jane.doe@example.com&quot; ) print(person.name) print(person.email) print(person.age()) . Nous commençons la définition de la classe avec le mot-clé class, suivi du nom de la classe et de deux points. Nous énumérerions toutes les classes parentes entre parenthèses avant les deux points, mais cette classe n&#39;en a pas, nous pouvons donc les laisser de côté. . À l&#39;intérieur du corps de la classe, nous définissons deux fonctions : ce sont les méthodes de notre objet. La première s&#39;appelle __init__, qui est une méthode spéciale. Lorsque nous appelons l&#39;objet de classe, une nouvelle instance de la classe est créée et la méthode __init__ sur ce nouvel objet est immédiatement exécutée avec tous les paramètres que nous avons passés à l&#39;objet de classe. Le but de cette méthode est donc de mettre en place un nouvel objet à partir des données que nous vous avons fournies. . La deuxième méthode est une méthode personnalisée qui calcule l&#39;âge de notre personne en utilisant la date de naissance et la date du jour. . 2. Le param&#232;tre self . Vous avez peut-être remarqué que ces deux définitions de méthode ont self comme premier paramètre, et nous utilisons cette variable à l&#39;intérieur des corps des méthodes mais nous ne semblons pas passer ce paramètre. C&#39;est parce que chaque fois que nous appelons une méthode sur un objet, l&#39;objet lui-même est automatiquement transmis comme premier paramètre. Cela nous donne un moyen d&#39;accéder aux propriétés de l&#39;objet depuis l&#39;intérieur des méthodes de l&#39;objet. . Vous devriez maintenant pouvoir voir que notre fonction __init__ crée des attributs sur l&#39;objet et les définit sur les valeurs que nous avons transmises en tant que paramètres. Nous utilisons les mêmes noms pour les attributs et les paramètres, mais ce n&#39;est pas obligatoire. . La fonction age ne prend aucun paramètre à l&#39;exception de self, elle utilise uniquement les informations stockées dans les attributs de l&#39;objet et la date actuelle (qu&#39;elle récupère à l&#39;aide du module datetime). . Notez que l&#39;attribut de date de naissance est lui-même un objet. La classe date est définie dans le module datetime, et nous créons une nouvelle instance de cette classe à utiliser comme paramètre de date de naissance lorsque nous créons une instance de la classe Person. Nous n&#39;avons pas à l&#39;affecter à une variable intermédiaire avant de l&#39;utiliser comme paramètre de Person. Nous pouvons simplement le créer lorsque nous appelons Person, tout comme nous créons des string pour les autres paramètres. . N&#39;oubliez pas que la définition d&#39;une fonction ne la fait pas s&#39;exécuter. Définir une classe ne fait pas non plus fonctionner quoi que ce soit, cela indique simplement à Python la classe. La classe ne sera pas définie tant que Python n&#39;aura pas exécuté l&#39;intégralité de la définition, vous pouvez donc être sûr de pouvoir référencer n&#39;importe quelle méthode à partir de n&#39;importe quelle autre méthode sur la même classe, ou même référencer la classe à l&#39;intérieur d&#39;une méthode de la classe. Au moment où vous appelez cette méthode, la classe entière sera définitivement définie. . Exercice 1 . Expliquez à quoi se réfèrent les variables suivantes et leur scope : . 1) Person | 2) person | 3) surname | 4) self | 5) age (le nom de la fonction) | 6) age (la variable utilisée dans la fonction) | 7) self.email | 8) person.email | . 3. Les attributs d&#39;une instance . Il est important de noter que les attributs définis sur l&#39;objet dans la fonction __init__ ne forment pas une liste exhaustive de tous les attributs que notre objet est autorisé à avoir. . Dans certains langages, vous devez fournir une liste des attributs de l&#39;objet dans la définition de classe, des espaces réservés sont créés pour ces attributs autorisés lors de la création de l&#39;objet et vous ne pouvez pas ajouter de nouveaux attributs à l&#39;objet ultérieurement. En Python, vous pouvez ajouter de nouveaux attributs, et même de nouvelles méthodes, à un objet à la volée. En fait, il n&#39;y a rien de spécial à propos de la fonction __init__ lorsqu&#39;il s&#39;agit de définir des attributs. Nous pourrions stocker une valeur d&#39;âge en cache sur l&#39;objet à l&#39;intérieur de la fonction d&#39;âge : . def age(self): if hasattr(self, &quot;_age&quot;): return self._age today = datetime.date.today() age = today.year - self.birthdate.year if today &lt; datetime.date(today.year, self.birthdate.month, self.birthdate.day): age -= 1 self._age = age return age . Nous pourrions même ajouter un attribut complètement indépendant de l&#39;extérieur de l&#39;objet : . person.pets = [&#39;cat&#39;, &#39;cat&#39;, &#39;dog&#39;] . Il est très courant que les méthodes d&#39;un objet mettent à jour les valeurs des attributs de l&#39;objet, mais il est considéré comme une mauvaise pratique de créer de nouveaux attributs dans une méthode sans les initialiser dans la méthode __init__. Définir des propriétés arbitraires depuis l&#39;extérieur de l&#39;objet est encore plus mal vu, car cela brise le paradigme orienté objet (dont nous parlerons dans le chapitre suivant). . La méthode __init__ sera certainement exécutée avant toute autre chose lorsque nous créons l&#39;objet, c&#39;est donc un bon endroit pour faire toute notre initialisation des données de l&#39;objet. Si nous créons un nouvel attribut en dehors de la méthode __init__, nous courons le risque d&#39;essayer de l&#39;utiliser avant qu&#39;il ne soit initialisé. . Dans l&#39;exemple age ci-dessus, nous devons vérifier si un attribut _age existe sur l&#39;objet avant d&#39;essayer de l&#39;utiliser, car si nous n&#39;avons pas exécuté la méthode age auparavant, elle n&#39;aura pas encore été créée. Ce serait beaucoup plus propre si nous appelions cette méthode au moins une fois depuis __init__, pour s&#39;assurer que _age est créé dès que nous créons l&#39;objet. . L&#39;initialisation de tous nos attributs dans __init__, même si nous les définissons simplement sur des valeurs vides, rend notre code moins sujet aux erreurs. Cela facilite également la lecture et la compréhension – nous pouvons voir en un coup d&#39;œil quels sont les attributs de notre objet. . Une méthode __init__ n&#39;a pas à prendre de paramètres (sauf self) et elle peut être complètement absente. . 4. Les fonctions getattr, setattr et hasattr . Que se passe-t-il si nous voulons obtenir ou définir la valeur d&#39;un attribut d&#39;un objet sans coder en dur son nom ? Nous pouvons parfois vouloir boucler plusieurs noms d&#39;attributs et effectuer la même opération sur chacun d&#39;eux. Pour faire cela nous utiliserons les fonctions : getattr, setattr et hasattr . La fonction hastattr . Cet fonction permet de savoir si un objet possède un attribut ou non : . print(hasattr(person, &#39;a&#39;)) person.a = &#39;hello&#39; print(hasattr(person, &#39;a&#39;)) . La fonction getattr . Cet fonction permet de récupérer la valeur d&#39;un attribut de l&#39;objet : . person.a = 12 person.b = &quot;hello&quot; person.c = .002 # Get person.a, person.b, etc. for key in [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]: print(getattr(person, key, None)) # Is equivalent to : print(person.a) print(person.b) print(person.c) print(person.d) # Oups this fails . La fonction setattr . Cet fonction permet de définir la valeur d&#39;un attribut d&#39;un objet. Par exemple, nous copions des données d&#39;un dictionnaire vers un objet : . mydict = {&#39;d&#39;: None, &#39;e&#39;: 321, &#39;f&#39;: &#39;World&#39;} for key, value in mydict.items(): setattr(person, key, mydict[key]) # Is equivalent to : person.d = None person.e = 321 person.f = &#39;World&#39; . Exercice 2 . Réécrivez la classe Person afin que l&#39;âge d&#39;une personne soit calculé pour la première fois lorsqu&#39;une nouvelle instance de personne est créée, et recalculé (lorsqu&#39;il est demandé) si le jour a changé depuis la dernière fois qu&#39;il a été calculé. . 5. Les attributs de classe . Tous les attributs définis sur une instance Person sont des attributs d&#39;instance, ils sont ajoutés à l&#39;instance lorsque la méthode __init__ est exécutée. Cependant, nous pouvons également définir des attributs qui sont définis sur la classe. Ces attributs seront partagés par toutes les instances de cette classe. À bien des égards, ils se comportent comme des attributs d&#39;instance, mais vous devez être conscient de certaines mises en garde. . Nous définissons les attributs de classe dans son corps, au même niveau d&#39;indentation que les définitions de méthode (un niveau au-dessus de l&#39;intérieur des méthodes) : . class Person: TITLES = (&#39;Dr&#39;, &#39;Mr&#39;, &#39;Mrs&#39;, &#39;Ms&#39;) def __init__(self, title, name, surname): if title not in self.TITLES: raise ValueError(&quot;%s is not a valid title.&quot; % title) self.title = title self.name = name self.surname = surname . Comme vous pouvez le voir, nous accédons à l&#39;attribut de classe TITLES comme nous accéderions à un attribut d&#39;instance, il est rendu disponible en tant que propriété sur l&#39;objet d&#39;instance, auquel nous accédons à l&#39;intérieur de la méthode via la variable self. . Tous les objets Person que nous créons partageront le même attribut de classe TITLES. . Les attributs de classe sont souvent utilisés pour définir des constantes qui sont étroitement associées à une classe particulière. Bien que nous puissions utiliser des attributs de classe à partir d&#39;instances de classe, nous pouvons également les utiliser à partir d&#39;objets de classe, sans créer d&#39;instance : . person.TITLES # but we can also access it from the class Person.TITLES . L&#39;objet de classe n&#39;a accès à aucun attribut d&#39;instance, ceux-ci ne sont créés que lorsqu&#39;une instance est créée : . Person.name Person.surname . Les attributs de classe peuvent également parfois être utilisés pour fournir des valeurs d&#39;attribut par défaut. . class Person: deceased = False def mark_as_deceased(self): self.deceased = True . Lorsque nous définissons un attribut sur une instance qui a le même nom qu&#39;un attribut de classe, nous remplaçons l&#39;attribut de classe par un attribut d&#39;instance, qui aura la priorité sur lui. Si nous créons deux objets Person et appelons la méthode mark_as_deceased sur l&#39;un d&#39;eux, nous n&#39;affecterons pas l&#39;autre. Nous devons cependant être prudents lorsqu&#39;un attribut de classe est de type mutable : car si nous le modifions sur place, nous affecterons tous les objets de cette classe en même temps. N&#39;oubliez pas que toutes les instances partagent les mêmes attributs de classe : . class Person: pets = [] def add_pet(self, pet): self.pets.append(pet) jane = Person() bob = Person() jane.add_pet(&quot;cat&quot;) print(jane.pets) print(bob.pets) # oops! . Ce que nous devrions faire dans des cas comme celui-ci, c&#39;est initialiser l&#39;attribut mutable en tant qu&#39;attribut d&#39;instance, à l&#39;intérieur de __init__. Ensuite, chaque instance aura sa propre copie distincte : . class Person: def __init__(self): self.pets = [] def add_pet(self, pet): self.pets.append(pet) jane = Person() bob = Person() jane.add_pet(&quot;cat&quot;) print(jane.pets) print(bob.pets) . Notez que les définitions de méthode sont dans le même scope que les définitions d&#39;attribut de classe, nous pouvons donc utiliser les noms d&#39;attribut de classe comme variables dans les définitions de méthode (sans self, qui n&#39;est défini qu&#39;à l&#39;intérieur des méthodes) : . class Person: TITLES = (&#39;Dr&#39;, &#39;Mr&#39;, &#39;Mrs&#39;, &#39;Ms&#39;) def __init__(self, title, name, surname, allowed_titles=TITLES): if title not in allowed_titles: raise ValueError(f&quot;{title} is not a valid title.&quot;) self.title = title self.name = name self.surname = surname . Exercice 3 . Expliquez les différences entre les attributs name, surname et profession, et quelles valeurs ils peuvent avoir dans différentes instances de cette classe : . class Smith: surname = &quot;Smith&quot; profession = &quot;smith&quot; def __init__(self, name, profession=None): self.name = name if profession is not None: self.profession = profession . 6. Les decorateurs de classe . @classmethod . Tout comme nous pouvons définir des attributs de classe, qui sont partagés entre toutes les instances d&#39;une classe, nous pouvons définir des méthodes de classe. Pour ce faire, nous utilisons le décorateur @classmethod pour décorer une méthode ordinaire. . Une méthode de classe a toujours son objet appelant comme premier paramètre, mais par convention nous renommerons ce paramètre de self en cls. Si nous appelons la méthode de classe depuis une instance, ce paramètre contiendra l&#39;objet instance, mais si nous l&#39;appelons depuis la classe, il contiendra l&#39;objet classe. En appelant le paramètre cls, nous nous rappelons qu&#39;il n&#39;est pas garanti d&#39;avoir des attributs d&#39;instance. . A quoi servent les méthodes de classe ? Parfois, il existe des tâches associées à une classe que nous pouvons effectuer à l&#39;aide de constantes et d&#39;autres attributs de classe, sans avoir besoin de créer d&#39;instances de classe. Si nous devions utiliser des méthodes d&#39;instance pour ces tâches, nous aurions besoin de créer une instance sans raison, ce qui serait un gaspillage. Parfois, nous écrivons des classes uniquement pour regrouper des constantes liées avec des fonctions qui agissent sur elles, nous pouvons ne jamais instancier ces classes du tout. . Parfois, il est utile d&#39;écrire une méthode de classe qui crée une instance de la classe après avoir traité l&#39;entrée afin qu&#39;elle soit dans le bon format pour être transmise au constructeur de classe. Cela permet au constructeur d&#39;être simple et de ne pas avoir à implémenter de code d&#39;analyse ou de nettoyage compliqué : . class Person: def __init__(self, name, surname, birthdate, address, telephone, email): self.name = name # (...) @classmethod def from_text_file(cls, filename): # extract all the parameters from the text file return cls(*params) # this is the same as calling Person(*params) . @staticmethod . L&#39;objet appelant n&#39;est pas transmis à une méthode statique comme premier paramètre. Cela signifie qu&#39;il n&#39;a pas du tout accès au reste de la classe ou de l&#39;instance. Nous pouvons les appeler à partir d&#39;une instance ou d&#39;un objet de classe, mais ils sont le plus souvent appelés à partir d&#39;objets de classe, comme les méthodes de classe. . Si nous utilisons une classe pour regrouper des méthodes liées qui n&#39;ont pas besoin d&#39;accéder les unes aux autres ou à d&#39;autres données sur la classe, nous pouvons utiliser cette technique. L&#39;avantage d&#39;utiliser des méthodes statiques est que nous éliminons les paramètres cls ou self inutiles de nos définitions de méthodes. L&#39;inconvénient est que si nous voulons occasionnellement faire référence à une autre méthode de classe ou à un autre attribut dans une méthode statique, nous devons écrire le nom de la classe en entier, ce qui peut être beaucoup plus détaillé que d&#39;utiliser la variable cls qui nous est disponible dans un méthode de classe. . Voici un exemple comparant les trois types de méthodes : . class Person: TITLES = (&#39;Dr&#39;, &#39;Mr&#39;, &#39;Mrs&#39;, &#39;Ms&#39;) def __init__(self, name, surname): self.name = name self.surname = surname def fullname(self): # instance method # instance object accessible through self return f&quot;{self.name} {self.surname}&quot; @classmethod def allowed_titles_starting_with(cls, startswith): # class method # class or instance object accessible through cls return [t for t in cls.TITLES if t.startswith(startswith)] @staticmethod def allowed_titles_ending_with(endswith): # static method # no parameter for class or instance object # we have to use Person directly return [t for t in Person.TITLES if t.endswith(endswith)] jane = Person(&quot;Jane&quot;, &quot;Smith&quot;) print(jane.fullname()) print(jane.allowed_titles_starting_with(&quot;M&quot;)) print(Person.allowed_titles_starting_with(&quot;M&quot;)) print(jane.allowed_titles_ending_with(&quot;s&quot;)) print(Person.allowed_titles_ending_with(&quot;s&quot;)) . @property . Parfois, nous utilisons une méthode pour générer dynamiquement une propriété d&#39;un objet, en la calculant à partir des autres propriétés de l&#39;objet. Parfois, vous pouvez simplement utiliser une méthode pour accéder à un seul attribut et le retourner. Vous pouvez également utiliser une méthode différente pour mettre à jour la valeur de l&#39;attribut au lieu d&#39;y accéder directement. De telles méthodes sont appelées getters et setters, car elles « obtiennent » et « définissent » respectivement les valeurs des attributs. . Dans certains langages, vous êtes encouragé à utiliser des getters et des setters pour tous les attributs, et à ne jamais accéder directement à leurs valeurs et il existe des fonctionnalités de langage qui peuvent rendre les attributs inaccessibles, sauf via les setters et les getters. En Python, accéder directement à des attributs simples est parfaitement acceptable, et écrire des getters et setters pour chacun d&#39;eux est considéré comme inutilement verbeux. Les setters peuvent être gênants car ils ne permettent pas l&#39;utilisation d&#39;opérateurs d&#39;affectation composés : . class Person: def __init__(self, height): self.height = height def get_height(self): return self.height def set_height(self, height): self.height = height jane = Person(153) # Jane is 153cm tall jane.height += 1 # Jane grows by a centimetre jane.set_height(jane.height + 1) # Jane grows again . Comme nous pouvons le voir, incrémenter l&#39;attribut height via un setter est beaucoup plus détaillé. Bien sûr, nous pourrions écrire un deuxième setter qui incrémente l&#39;attribut par le paramètre donné, mais nous devrions faire quelque chose de similaire pour chaque attribut et chaque type de modification que nous voulons effectuer. Nous aurions un problème similaire avec les modifications sur place, comme l&#39;ajout de valeurs aux listes. . Quelque chose qui est souvent considéré comme un avantage des setters et des getters est que nous pouvons changer la façon dont un attribut est généré à l&#39;intérieur de l&#39;objet sans affecter le code qui utilise l&#39;objet. Par exemple, supposons que nous ayons initialement créé une classe Person qui a un attribut de nom complet, mais que nous voulions plus tard changer la classe pour avoir des attributs de nom et de famille séparés que nous combinons pour créer un nom complet. Si nous accédons toujours à l&#39;attribut fullname via un setter, nous pouvons simplement réécrire le setter, aucun code qui appelle le setter ne devra être modifié. . Mais que se passe-t-il si notre code accède directement à l&#39;attribut fullname ? Nous pouvons écrire une méthode de nom complet qui renvoie la bonne valeur, mais une méthode doit être appelée. Heureusement, le décorateur @property nous permet de faire en sorte qu&#39;une méthode se comporte comme un attribut : . class Person: def __init__(self, name, surname): self.name = name self.surname = surname @property def fullname(self): return &quot;%s %s&quot; % (self.name, self.surname) jane = Person(&quot;Jane&quot;, &quot;Smith&quot;) print(jane.fullname) # no brackets! . Il existe également des décorateurs que nous pouvons utiliser pour définir un setter et un deleter pour notre attribut (un deleter supprimera l&#39;attribut de notre objet). Les méthodes getter, setter et deleter doivent toutes avoir le même nom : . class Person: def __init__(self, name, surname): self.name = name self.surname = surname @property def fullname(self): return &quot;%s %s&quot; % (self.name, self.surname) @fullname.setter def fullname(self, value): # this is much more complicated in real life name, surname = value.split(&quot; &quot;, 1) self.name = name self.surname = surname @fullname.deleter def fullname(self): del self.name del self.surname jane = Person(&quot;Jane&quot;, &quot;Smith&quot;) print(jane.fullname) jane.fullname = &quot;Jane Doe&quot; print(jane.fullname) print(jane.name) print(jane.surname) . Exercice 4 . Créez une classe appelée Numbers, qui a un seul attribut de classe appelé MULTIPLIER, et un constructeur qui prend les paramètres x et y (ceux-ci doivent tous être des nombres). . 1) Écrivez une méthode appelée add qui renvoie la somme des attributs x et y. | 2) Écrivez une méthode de classe appelée multiply, qui prend un seul paramètre numérique a et renvoie le produit de a et de MULTIPLIER. | 3) Écrivez une méthode statique appelée subtract, qui prend deux paramètres numériques : b et c, et renvoie b - c. | 4) Écrivez une méthode appelée value qui renvoie un tuple contenant les valeurs de x et y. Transformez cette méthode en propriété et écrivez un setter et un deleter pour manipuler les valeurs de x et y. | . 7. Inspecter un objet . Nous pouvons vérifier quelles propriétés sont définies sur un objet en utilisant la fonction dir : . class Person: def __init__(self, name, surname): self.name = name self.surname = surname def fullname(self): return &quot;%s %s&quot; % (self.name, self.surname) jane = Person(&quot;Jane&quot;, &quot;Smith&quot;) print(dir(jane)) . Maintenant, nous pouvons voir nos attributs et notre méthode. Mais qu&#39;est-ce que c&#39;est que tous ces autres trucs ? Nous discuterons de l&#39;héritage dans le chapitre suivant, mais pour l&#39;instant tout ce que vous devez savoir est que toute classe que vous définissez a un objet comme classe parent même si vous ne le dites pas explicitement, votre classe aura donc beaucoup d&#39;attributs par défaut et les méthodes de tout objet Python. . C&#39;est pourquoi vous pouvez simplement omettre la méthode __init__ de votre classe si vous n&#39;avez aucune initialisation à faire, la valeur par défaut que vous avez héritée de object (qui ne fait rien) sera utilisée à la place. Si vous écrivez votre propre méthode __init__, elle remplacera (override) la méthode par défaut. . De nombreuses méthodes et attributs par défaut que l&#39;on trouve dans les objets Python de base ont des noms qui commencent et se terminent par des traits de soulignement doubles, comme __init__ ou __str__. Ces noms indiquent que ces propriétés ont une signification particulière, vous ne devez pas créer vos propres méthodes ou attributs avec les mêmes noms, à moins que vous ne vouliez les surcharger. Ces propriétés sont généralement des méthodes, et elles sont parfois appelées méthodes magiques. . Nous pouvons utiliser dir sur n&#39;importe quel objet. Vous pouvez essayer de l&#39;utiliser sur toutes sortes d&#39;objets que nous avons déjà vus auparavant, comme des nombres, des listes, des chaînes et des fonctions, pour voir quelles propriétés intégrées ces objets ont en commun. . Voici quelques exemples de propriétés d&#39;objets spéciaux : . __init__ : la méthode d&#39;initialisation d&#39;un objet, qui est appelée lors de la création de l&#39;objet. | __str__ : la méthode de représentation sous forme de chaîne d&#39;un objet, qui est appelée lorsque vous utilisez la fonction str pour convertir cet objet en une chaîne. | __class__ : un attribut qui stocke la classe (ou le type) d&#39;un objet, c&#39;est ce qui est renvoyé lorsque vous utilisez la fonction type sur l&#39;objet. | __eq__ : une méthode qui détermine si cet objet est égal à un autre. Il existe également d&#39;autres méthodes pour déterminer si ce n&#39;est pas égal, inférieur à, etc. Ces méthodes sont utilisées dans les comparaisons d&#39;objets, par exemple lorsque nous utilisons l&#39;opérateur d&#39;égalité == pour vérifier si deux objets sont égaux. | __add__ est une méthode qui permet d&#39;ajouter cet objet à un autre objet. Il existe des méthodes équivalentes pour tous les autres opérateurs arithmétiques. Tous les objets ne prennent pas en charge toutes les opérations arithmétiques, les nombres ont toutes ces méthodes définies, mais d&#39;autres objets peuvent n&#39;avoir qu&#39;un sous-ensemble. | __iter__ : une méthode qui renvoie un itérateur sur l&#39;objet, nous le trouverons sur des chaînes, des listes et d&#39;autres itérables. Il est exécuté lorsque nous utilisons la fonction iter sur l&#39;objet. | __len__ : une méthode qui calcule la longueur d&#39;un objet, on la retrouvera sur des séquences. Il est exécuté lorsque nous utilisons la fonction len d&#39;un objet. | __dict__ : un dictionnaire qui contient tous les attributs d&#39;instance d&#39;un objet, avec leurs noms comme clés. Cela peut être utile si nous voulons itérer sur tous les attributs d&#39;un objet. __dict__ n&#39;inclut aucune méthode, attribut de classe ou attribut par défaut spécial comme __class__. | . Exercice 5 . Créez une instance de la classe Person de l&#39;exemple 2. Utilisez la fonction dir sur l&#39;instance. Ensuite, utilisez la fonction dir sur la classe. . 1) Que se passe-t-il si vous appelez la méthode __str__ sur l&#39;instance ? Vérifiez que vous obtenez le même résultat si vous appelez la fonction str avec l&#39;instance comme paramètre. | 2) Quel est le type de l&#39;instance ? | 3) Quel est le type de classe ? | 4) Écrivez une fonction qui affiche les noms et les valeurs de tous les attributs personnalisés de tout objet transmis en tant que paramètre. | . Remplacer les m&#233;thodes magiques . class Person: def __init__(self, name, surname): self.name = name self.surname = surname def __str__(self): return f&quot;{self.name} {self.surname}&quot; def __eq__(self, other): # does self == other? return self.name == other.name and self.surname == other.surname def __gt__(self, other): # is self &gt; other? if self.surname == other.surname: return self.name &gt; other.name return self.surname &gt; other.surname # now we can define all the other methods in terms of the first two def __ne__(self, other): # does self != other? return not self == other # this calls self.__eq__(other) def __le__(self, other): # is self &lt;= other? return not self &gt; other # this calls self.__gt__(other) def __lt__(self, other): # is self &lt; other? return not (self &gt; other or self == other) def __ge__(self, other): # is self &gt;= other? return not self &lt; other .",
            "url": "https://axi-technologies.github.io/AXI-Fastpages/python-intro-gen/chapter/6/lesson/1/",
            "relUrl": "/python-intro-gen/chapter/6/lesson/1/",
            "date": " • Jan 2, 2022"
        }
        
    
  
    
        ,"post2": {
            "title": "Chapitre 5 : Les fonctions",
            "content": "1. Introduction aux fonctions (def) . Une fonction est une séquence d&#39;instructions qui effectue une tâche. Nous utilisons des fonctions pour éliminer la duplication de code : au lieu d&#39;écrire toutes les instructions à chaque endroit de notre code où nous voulons effectuer la même tâche, nous les définissons en un seul endroit et nous y référons par le nom de la fonction. Si nous voulons changer la façon dont cette tâche est effectuée, nous n&#39;aurons plus besoin que de changer le code à un seul endroit. . Voici une définition d&#39;une fonction simple qui ne prend aucun paramètre et ne renvoie aucune valeur : . def print_a_message(): print(&quot;Hello, world!&quot;) . Nous utilisons l&#39;instruction def pour indiquer le début d&#39;une définition de fonction. La partie suivante de la définition est le nom de la fonction, dans ce cas : print_a_message, suivi de parenthèses (les définitions de tous les paramètres pris par la fonction seront placées entre elles) et de deux points. Par la suite, tout ce qui est indenté d&#39;un niveau est le corps de la fonction. . Les fonctions font toutes sortes de choses, vous devez donc toujours choisir un nom de fonction qui explique aussi simplement que possible ce que fait la fonction. Ce sera généralement un verbe ou une phrase contenant un verbe. Si vous modifiez tellement une fonction que le nom ne reflète plus exactement ce qu&#39;elle fait, vous devriez envisager de mettre à jour le nom, bien que cela puisse parfois être gênant. . Cette fonction particulière fait toujours exactement la même chose : elle affiche le message &quot;Hello, world!&quot;. . Définir une fonction ne la fait pas s&#39;exécuter, lorsque le flux de contrôle atteint la définition de la fonction et l&#39;exécute, Python apprend simplement la fonction et ce qu&#39;elle fera lorsque nous l&#39;exécuterons. Pour exécuter une fonction, nous devons l&#39;appeler. Pour appeler la fonction, nous utilisons son nom suivi de parenthèses (avec tous les paramètres que la fonction prend entre eux): . print_a_message() . Nous avons déjà utilisé de nombreuses fonctions intégrées de Python, telles que print et len ​​: . print(&quot;Hello&quot;) len([1, 2, 3]) . De nombreux objets en Python sont appelables (callable), ce qui signifie que vous pouvez les appeler comme des fonctions : un objet callable a une méthode spéciale définie qui est exécutée lorsque l&#39;objet est appelé. Par exemple, des types tels que str, int ou list peuvent être utilisés comme fonctions, pour créer de nouveaux objets de ce type (parfois en convertissant un objet existant) : . num_str = str(3) num = int(&quot;3&quot;) people = list() # make a new (empty) list people = list((1, 2, 3)) # convert a tuple to a new list . Les fonctions sont des objets en Python, nous pouvons les traiter comme n&#39;importe quel autre objet : nous pouvons affecter une fonction comme valeur d&#39;une variable. Pour faire référence à une fonction sans l&#39;appeler, nous utilisons simplement le nom de la fonction sans parenthèses : . my_function = print_a_message # later we can call the function using the variable name my_function() . La définition d&#39;une fonction ne provoque pas son exécution, nous pouvons utiliser un objet à l&#39;intérieur d&#39;une fonction même s&#39;il n&#39;a pas encore été définie. Tant qu&#39;il est défini au moment où nous exécutons la fonction. Par exemple, si nous définissons plusieurs fonctions qui s&#39;appellent toutes, l&#39;ordre dans lequel nous les définissons n&#39;a pas d&#39;importance tant qu&#39;elles sont toutes définies avant de commencer à les utiliser : . def my_function(): my_other_function() def my_other_function(): print(&quot;Hello!&quot;) # this is fine, because my_other_function is now defined my_function() . Si nous devions déplacer cet appel de fonction, nous obtiendrions une erreur : . def my_function(): my_other_function() # this is not fine, because my_other_function is not defined yet! my_function() def my_other_function(): print(&quot;Hello!&quot;) . 2. Les param&#232;tres d&#39;entr&#233;e . Il est très rare que la tâche que nous voulons effectuer avec une fonction soit toujours exactement la même. Il y a généralement des différences mineures par rapport à ce que nous devons faire dans différentes circonstances. Nous ne voulons pas écrire une fonction légèrement différente pour chacun de ces cas légèrement différents, cela irait à l&#39;encontre du principe : éviter les répétitions de code. Au lieu de cela, nous voulons transmettre des informations à la fonction et les utiliser à l&#39;intérieur de la fonction pour adapter le comportement de la fonction à nos besoins exacts. Nous exprimons cette information sous la forme d&#39;une série de paramètres d&#39;entrée. . Par exemple, nous pouvons rendre la fonction que nous avons définie ci-dessus plus utile si nous rendons le message personnalisable : . def print_a_message(message): print(message) . Nous pouvons aussi passer deux nombres et les additionner. Lorsque nous appelons cette fonction, nous devons passer deux paramètres, ou nous obtiendrons une erreur : . def print_sum(a, b): print(a + b) print_sum() # this won&#39;t work print_sum(2, 3) # this is correct . Dans l&#39;exemple ci-dessus, nous passons 2 et 3 comme paramètres à la fonction lorsque nous l&#39;appelons. Cela signifie que lors de l&#39;exécution de la fonction, la variable a recevra la valeur 2 et la variable b la valeur 3. Vous pourrez alors vous référer à ces valeurs en utilisant les noms de variables a et b à l&#39;intérieur de la fonction. . Dans les langages à typage statique, nous devons déclarer les types de paramètres lorsque nous définissons la fonction, et nous ne pouvons utiliser des variables de ces types que lorsque nous appelons la fonction. Si nous voulons effectuer une tâche similaire avec des variables de types différents, nous devons définir une fonction distincte qui accepte ces types. . En Python, les paramètres n&#39;ont pas de types déclarés. Nous pouvons transmettre n&#39;importe quel type de variable à la fonction print_message ci-dessus, pas seulement une string. Nous pouvons utiliser la fonction print_sum pour ajouter deux éléments qui peuvent être ajoutés : deux entiers, deux flottants, un entier et un flottant, ou même deux chaînes. Nous pouvons également passer un entier et une chaîne, mais bien que ceux-ci soient autorisés en tant que paramètres, ils ne peuvent pas être additionnés, nous obtiendrons donc une erreur lorsque nous essaierons de les ajouter à l&#39;intérieur de la fonction. . L&#39;avantage de ceci est que nous n&#39;avons pas à écrire beaucoup de fonctions print_sum différentes, une pour chaque paire de types différente, alors qu&#39;elles seraient toutes identiques autrement. L&#39;inconvénient est que puisque Python ne vérifie pas les types de paramètres par rapport à la définition de la fonction lorsqu&#39;une fonction est appelée, nous pouvons ne pas remarquer immédiatement si le mauvais type de paramètre est transmis - si, par exemple, une autre personne interagit avec le code que nous avons écrit utilise des types de paramètres que nous n&#39;avions pas anticipés, ou si nous obtenons accidentellement les paramètres dans le désordre. . C&#39;est pourquoi il est important pour nous de tester notre code à fond (ce que nous verrons dans un chapitre ultérieur). Si nous avons l&#39;intention d&#39;écrire du code robuste, surtout s&#39;il doit également être utilisé par d&#39;autres personnes, c&#39;est aussi souvent une bonne idée de vérifier les paramètres de la fonction au début de la fonction et de donner un retour à l&#39;utilisateur (en levant des exceptions) si le sont incorrects. . Exercice 2 . 1) Créez une fonction appelée hypotenuse, qui prend deux nombres comme paramètres et imprime la racine carrée de la somme de leurs carrés. | 2) Appelez cette fonction avec deux flottants. | 3) Appelez cette fonction avec deux entiers. | 4) Appelez cette fonction avec un entier et un flottant. | . 3. Les valeurs de retour (return) . Les exemples de fonctions que nous avons vus ci-dessus ne renvoient aucune valeur, ils affichent simplement un message. Nous voulons souvent utiliser une fonction pour calculer une sorte de valeur, puis nous la renvoyer, afin que nous puissions la stocker dans une variable et l&#39;utiliser plus tard. La sortie renvoyée par une fonction est appelée valeur de retour. Nous pouvons réécrire la fonction print_sum pour renvoyer le résultat de son addition au lieu de l&#39;afficher : . def add(a, b): return a + b . Nous utilisons le mot-clé return pour définir une valeur de retour. Pour accéder à cette valeur lorsque nous appelons la fonction, nous devons affecter le résultat de la fonction à une variable : . c = add(23, 13) . Ici, la valeur de retour de la fonction sera affectée à c lorsque la fonction est exécutée. . Une fonction ne peut avoir qu&#39;une seule valeur de retour, mais cette valeur peut être une liste ou un tuple, donc en pratique, vous pouvez retourner autant de valeurs différentes d&#39;une fonction que vous le souhaitez. Il n&#39;est généralement logique de renvoyer plusieurs valeurs que si elles sont liées les unes aux autres d&#39;une manière ou d&#39;une autre. Si vous placez plusieurs valeurs après l&#39;instruction return, séparées par des virgules, elles seront automatiquement converties en un tuple. Inversement, vous pouvez affecter un tuple à plusieurs variables séparées par des virgules en même temps, vous pouvez donc décompresser un tuple renvoyé par une fonction en plusieurs variables . def divide(dividend, divisor): quotient = dividend // divisor remainder = dividend % divisor return quotient, remainder # you can do this q, r = divide(35, 4) # but you can also do this result = divide(67, 9) q1 = result[0] q2 = result[1] # by the way, you can also do this a, b = (1, 2) # or this c, d = [5, 6] . Que se passe-t-il si vous essayez d&#39;affecter l&#39;un de nos premiers exemples, qui n&#39;ont pas de valeur de retour, à une variable ? . mystery_output = print_a_message(&quot;Boo!&quot;) print(mystery_output) . Toutes les fonctions renvoient en fait quelque chose, même si nous ne définissons pas de valeur de retour : la valeur de retour par défaut est None, ce qui correspond à la valeur de notre sortie mystère. . Lorsqu&#39;une instruction return est atteinte, le flux de contrôle quitte immédiatement la fonction : toute autre instruction dans le corps de la fonction sera ignorée. Nous pouvons parfois utiliser cela à notre avantage pour réduire le nombre d&#39;instructions conditionnelles que nous devons utiliser dans une fonction : . def divide(dividend, divisor): if not divisor: return None, None # instead of dividing by zero quotient = dividend // divisor remainder = dividend % divisor return quotient, remainder . Si la clause if est exécutée, le premier retour entraînera la sortie de la fonction. Donc tout ce qui vient après la clause if n&#39;a pas besoin d&#39;être à l&#39;intérieur d&#39;un else. Les instructions restantes peuvent simplement être dans le corps principal de la fonction, car elles ne peuvent être atteintes que si la clause if n&#39;est pas exécutée. . Cette technique peut être utile chaque fois que nous voulons vérifier les paramètres au début d&#39;une fonction - cela signifie que nous n&#39;avons pas à indenter la partie principale de la fonction à l&#39;intérieur d&#39;un bloc else. Parfois, il est plus approprié de lever une exception au lieu de renvoyer une valeur comme None s&#39;il y a un problème avec l&#39;un des paramètres : . def divide(dividend, divisor): if not divisor: raise ValueError(&quot;The divisor cannot be zero!&quot;) quotient = dividend // divisor remainder = dividend % divisor return quotient, remainder . Le fait d&#39;avoir plusieurs points de sortie dispersés dans votre fonction peut rendre votre code difficile à lire, la plupart des gens s&#39;attendent à un seul retour juste à la fin d&#39;une fonction. Vous devez utiliser cette technique avec parcimonie. . Exercice 3 . 1) Réécrivez la fonction hypotenuse de l&#39;exercice 2 afin qu&#39;elle renvoie une valeur au lieu de l&#39;àfficher. Ajoutez la gestion des exceptions afin que la fonction renvoie None si elle est appelée avec des paramètres du mauvais type. | 2) Appelez la fonction avec deux nombres et afficher le résultat. | 3) Appelez la fonction avec deux string et afficher le résultat. | 4) Appelez la fonction avec un nombre et une string et afficher le résultat. | . 4. La pile (stack) . Python stocke des informations sur les fonctions qui ont été appelées dans une pile d&#39;appels. Chaque fois qu&#39;une fonction est appelée, un nouveau cadre de pile est ajouté à la pile, tous les paramètres de la fonction y sont ajoutés, et au fur et à mesure que le corps de la fonction est exécuté, des variables locales y seront créées. Lorsque l&#39;exécution de la fonction est terminée, son cadre de pile est ignoré et le flux de contrôle revient à l&#39;endroit où vous étiez avant d&#39;appeler la fonction, au niveau précédent de la pile. . Si vous vous souvenez de la section sur la portée des variables du début du cours, cela explique un peu plus sur la façon dont les noms de variables sont résolus. Lorsque vous utilisez un identifiant, Python le recherchera d&#39;abord au niveau actuel de la pile, et s&#39;il ne le trouve pas, il vérifiera le niveau précédent, et ainsi de suite, jusqu&#39;à ce que la variable soit trouvée ou non. Si la variable n&#39;est pas trouvée et vous obtenez une erreur. C&#39;est pourquoi une variable locale aura toujours la priorité sur une variable globale de même nom. . Python recherche également dans la pile chaque fois qu&#39;il gère une exception : il vérifie d&#39;abord si l&#39;exception peut être gérée dans la fonction actuelle, et s&#39;il ne le peut pas, il termine la fonction et essaie la suivante, jusqu&#39;à ce que l&#39;exception soit gérée à un certain niveau ou le programme lui-même doit se terminer. La stacktrace que vous voyez lorsqu&#39;une exception est affiché montre le chemin emprunté par Python dans la pile. . 5. La recursion . Nous pouvons faire un appel de fonction elle-même. C&#39;est ce qu&#39;on appelle la récursivité. Un exemple courant est une fonction qui calcule des nombres dans la séquence de Fibonacci (0, 1, 1, 2, 3, 5, 8, 13) : le zéro-ième nombre est 0, le premier nombre est 1, et chaque nombre suivant est la somme des deux nombres précédents : . def fibonacci(n): if n == 0: return 0 if n == 1: return 1 return fibonacci(n - 1) + fibonacci(n - 2) . Chaque fois que nous écrivons une fonction récursive, nous devons inclure une sorte de condition qui lui permettra d&#39;arrêter la récursivité : un cas final dans lequel la fonction ne s&#39;appelle pas elle-même. Dans cet exemple, cela se produit au début de la séquence : les deux premiers nombres ne sont pas calculés à partir des nombres précédents : ce sont des constantes. . Que se passerait-il si nous omettions cette condition de notre fonction ? Lorsque nous arrivions à n = 2, nous continuions à appeler la fonction, en essayant de calculer fibonacci(0), fibonacci(-1) et ainsi de suite. En théorie, la fonction finirait par se répéter indéfiniment et ne se terminerait jamais, mais en pratique, le programme plantera avec une RuntimeError et un message indiquant que nous avons dépassé la profondeur de récursivité maximale. C&#39;est parce que la pile de Python a une taille finie, si nous continuons à placer des instances de la fonction sur la pile, nous finirons par la remplir et provoquer un débordement de la pile. Python se protège des débordements de pile en fixant une limite au nombre de fois qu&#39;une fonction est autorisée à se répéter. . Les fonctions récursives peuvent aussi être écrit avec des boucles : . def fibonacci(n): current, next = 0, 1 for i in range(n): current, next = next, current + next return current . Exercice 4 . Écrivez une fonction récursive qui calcule la factorielle d&#39;un nombre donné (exemple : 4! = 1 × 2 × 3 × 4 = 24). Utilisez la gestion des exceptions pour lever une exception appropriée si le paramètre d&#39;entrée n&#39;est pas un entier positif, mais autorisez l&#39;utilisateur à entrer des nombres flottants tant qu&#39;il s&#39;agit de nombres entiers. . 6. Param&#232;tres par d&#233;faut . La combinaison du nom de la fonction et du nombre de paramètres qu&#39;elle prend s&#39;appelle la signature de la fonction. Dans les langages à typage statique, il peut y avoir plusieurs fonctions avec le même nom dans la même portée tant qu&#39;elles ont des nombres ou des types de paramètres différents (dans ces langages, les types de paramètres et les types de retour font également partie de la signature). . En Python, il ne peut y avoir qu&#39;une seule fonction avec un nom particulier défini dans la portée, si vous définissez une autre fonction avec le même nom, vous écraserez la première fonction. Vous devez appeler cette fonction avec le bon nombre de paramètres, sinon vous obtiendrez une erreur. . Parfois, il y a une bonne raison de vouloir avoir deux versions de la même fonction avec des jeux de paramètres différents. Vous pouvez obtenir quelque chose de similaire en rendant certains paramètres facultatifs. Pour rendre un paramètre facultatif, nous devons lui fournir une valeur par défaut. Les paramètres facultatifs doivent venir après tous les paramètres requis dans la définition de la fonction : . def make_greeting(title, name, surname, formal=True): if formal: return f&quot;Hello, {title} {surname} !&quot; return f&quot;Hello, {name} !&quot; print(make_greeting(&quot;Mr&quot;, &quot;John&quot;, &quot;Smith&quot;)) print(make_greeting(&quot;Mr&quot;, &quot;John&quot;, &quot;Smith&quot;, False)) . Lorsque nous appelons la fonction, nous pouvons laisser le paramètre facultatif de côté. Si nous le faisons, la valeur par défaut sera utilisée. Si nous incluons le paramètre, notre valeur remplacera la valeur par défaut. . Nous pouvons définir plusieurs paramètres optionnels : . def make_greeting(title, name, surname, formal=True, time=None): if formal: fullname = f&quot;{title} {surname}&quot; else: fullname = name if time is None: greeting = &quot;Hello&quot; else: greeting = f&quot;Good {time}&quot; return f&quot;{greeting}, {fullname}!&quot; print(make_greeting(&quot;Mr&quot;, &quot;John&quot;, &quot;Smith&quot;)) print(make_greeting(&quot;Mr&quot;, &quot;John&quot;, &quot;Smith&quot;, False)) print(make_greeting(&quot;Mr&quot;, &quot;John&quot;, &quot;Smith&quot;, False, &quot;evening&quot;)) . Et si on voulait passer le deuxième paramètre optionnel, mais pas le premier ? Jusqu&#39;à présent, nous avons transmis des paramètres de position à toutes ces fonctions, un tuple de valeurs qui sont mises en correspondance avec des paramètres dans la signature de la fonction en fonction de leurs positions. Nous pouvons également, transmettre ces valeurs en tant que paramètres de mot-clé, nous pouvons spécifier explicitement les noms des paramètres avec les valeurs : . print(make_greeting(title=&quot;Mr&quot;, name=&quot;John&quot;, surname=&quot;Smith&quot;)) print(make_greeting(title=&quot;Mr&quot;, name=&quot;John&quot;, surname=&quot;Smith&quot;, formal=False, time=&quot;evening&quot;)) . Nous pouvons mélanger des paramètres de position et de mot-clé, mais les paramètres de mot-clé doivent venir après tous les paramètres de position : . print(make_greeting(&quot;Mr&quot;, &quot;John&quot;, surname=&quot;Smith&quot;)) # this will give you an error print(make_greeting(title=&quot;Mr&quot;, &quot;John&quot;, &quot;Smith&quot;)) # we can specify keyword parameters in any order print(make_greeting(surname=&quot;Smith&quot;, name=&quot;John&quot;, title=&quot;Mr&quot;)) # Pass in the second optional parameter and not the first print(make_greeting(&quot;Mr&quot;, &quot;John&quot;, &quot;Smith&quot;, time=&quot;evening&quot;)) . 7. Types mutables et param&#232;tres par d&#233;faut . Nous devons être prudents lorsque nous utilisons des types mutables comme valeurs de paramètre par défaut dans les définitions de fonctions si nous avons l&#39;intention de les modifier sur place : . def add_pet_to_list(pet, pets=[]): pets.append(pet) return pets list_with_cat = add_pet_to_list(&quot;cat&quot;) list_with_dog = add_pet_to_list(&quot;dog&quot;) print(list_with_cat) print(list_with_dog) # oops . N&#39;oubliez pas que bien que nous puissions exécuter un corps de fonction plusieurs fois, une définition de fonction n&#39;est exécutée qu&#39;une seule fois - cela signifie que la liste vide qui est créée dans cette définition de fonction sera la même liste pour toutes les instances de la fonction. Ce que nous voulons vraiment faire dans ce cas est de créer une liste vide à l&#39;intérieur du corps de la fonction : . def add_pet_to_list(pet, pets=None): pets = pets or [] pets.append(pet) return pets . Exercice 5 . 1) Écrivez une fonction appelée calculator. Il doit prendre les paramètres suivants : deux nombres, une opération arithmétique (qui peut être une addition, une soustraction, une multiplication ou une division et est une addition par défaut), et un format de sortie (qui peut être un entier ou une virgule flottante, et est une virgule flottante par défaut ). La division doit être une division à virgule flottante. . La fonction doit effectuer l&#39;opération demandée sur les deux nombres d&#39;entrée et renvoyer un résultat dans le format demandé (si le format est un entier, le résultat doit être arrondi et pas seulement tronqué). Levez des exceptions si nécessaire si l&#39;un des paramètres transmis à la fonction n&#39;est pas valide. . | 2) Appelez la fonction avec les ensembles de paramètres suivants et vérifiez que la réponse est celle que vous attendez : . 2, 3.0 | 2, 3.0, le format de sortie est un entier | 2, 3.0, l&#39;opération est la division | 2, 3.0, l&#39;opération est la division, le format de sortie est un entier | . | . 8. *args et **kwargs . Parfois, nous pouvons vouloir passer une liste de longueur variable de paramètres de position ou de mots-clés dans une fonction. Nous pouvons mettre * avant un nom de paramètre pour indiquer qu&#39;il s&#39;agit d&#39;un tuple de longueur variable de paramètres positionnels, et nous pouvons utiliser ** pour indiquer qu&#39;un paramètre est un dictionnaire de longueur variable de paramètres de mots-clés. Par convention, le nom de paramètre que nous utilisons pour le tuple est args et le nom que nous utilisons pour le dictionnaire est kwargs : . def print_args(*args): for arg in args: print(arg) def print_kwargs(**kwargs): for k, v in kwargs.items(): print(&quot;%s: %s&quot; % (k, v)) . À l&#39;intérieur de la fonction, nous pouvons accéder à args en tant que tuple normal, mais le * signifie que args n&#39;est pas transmis à la fonction en tant que paramètre unique qui est un tuple : à la place, il est transmis comme une série de paramètres individuels. De même, ** signifie que kwargs est transmis comme une série de paramètres de mots clés individuels, plutôt qu&#39;un seul paramètre qui est un dictionnaire : . print_args(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;) print_args(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;) print_kwargs(name=&quot;Jane&quot;, surname=&quot;Doe&quot;) print_kwargs(age=10) . Nous pouvons utiliser * ou ** lorsque nous appelons une fonction pour décompresser une séquence ou un dictionnaire en une série de paramètres individuels : . my_list = [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;] print_args(*my_list) my_dict = {&quot;name&quot;: &quot;Jane&quot;, &quot;surname&quot;: &quot;Doe&quot;} print_kwargs(**my_dict) . Cela facilite la création de listes de paramètres par programmation. Notez que nous pouvons l&#39;utiliser pour n&#39;importe quelle fonction, pas seulement celle qui utilise *args ou **kwargs : . my_dict = { &quot;title&quot;: &quot;Mr&quot;, &quot;name&quot;: &quot;John&quot;, &quot;surname&quot;: &quot;Smith&quot;, &quot;formal&quot;: False, &quot;time&quot;: &quot;evening&quot;, } print(make_greeting(**my_dict)) . Nous pouvons mélanger des paramètres ordinaires, *args et **kwargs dans la même définition de fonction. *args et **kwargs doivent venir après tous les autres paramètres, et **kwargs doit venir après *args. Vous ne pouvez pas avoir plus d&#39;un paramètre de liste de longueur variable ou plus d&#39;un paramètre de dict variable (rappelez-vous que vous pouvez les appeler comme vous le souhaitez) : . def print_everything(name, time=&quot;morning&quot;, *args, **kwargs): print(f&quot;Good {time}, {name}.&quot;) for arg in args: print(arg) for k, v in kwargs.items(): print(f&quot;{k}: {v}&quot;) . Si nous utilisons une expression * lorsque vous appelez une fonction, elle doit venir après tous les paramètres de position, et si nous utilisons une expression **, elle doit venir juste à la fin : . def print_everything(name, time=&quot;morning&quot;, *args, **kwargs): for arg in args: print(arg) for k, v in kwargs.items(): print(f&quot;{k}: {v}&quot;) # we can write all the parameters individually print_everything(&quot;cat&quot;, &quot;dog&quot;, day=&quot;Tuesday&quot;) t = (&quot;cat&quot;, &quot;dog&quot;) d = {&quot;day&quot;: &quot;Tuesday&quot;} # we can unpack a tuple and a dictionary print_everything(*t, **d) # or just one of them print_everything(*t, day=&quot;Tuesday&quot;) print_everything(&quot;cat&quot;, &quot;dog&quot;, **d) # we can mix * and ** with explicit parameters print_everything(&quot;Jane&quot;, *t, **d) print_everything(&quot;Jane&quot;, *t, time=&quot;evening&quot;, **d) print_everything(time=&quot;evening&quot;, *t, **d) # none of these are allowed: print_everything(*t, &quot;Jane&quot;, **d) print_everything(*t, **d, time=&quot;evening&quot;) . Si une fonction ne prend que *args et **kwargs comme paramètres, elle peut être appelée avec n&#39;importe quel ensemble de paramètres. Un ou les deux args et kwargs peuvent être vides, de sorte que la fonction accepte toute combinaison de paramètres de position et de mot-clé, y compris aucun paramètre. Cela peut être utile si nous écrivons une fonction très générique, comme print_everything dans l&#39;exemple ci-dessus. . Exercice 6 . Réécrivez la fonction calculatrice de l&#39;exercice 4 afin qu&#39;elle prenne un nombre quelconque de paramètres numériques ainsi que les mêmes paramètres de mot-clé facultatifs. La fonction doit appliquer l&#39;opération aux deux premiers nombres, puis l&#39;appliquer à nouveau au résultat et au nombre suivant, et ainsi de suite. Par exemple, si les nombres sont 6, 4, 9 et 1 et que l&#39;opération est une soustraction, la fonction doit renvoyer 6 - 4 - 9 - 1. Si un seul nombre est entré, il doit être renvoyé tel quel. Si aucun nombre n&#39;est entré, levez une exception. . 9. Les d&#233;corateurs . Parfois, nous pouvons avoir besoin de modifier plusieurs fonctions de la même manière. Par exemple, nous pouvons vouloir effectuer une action particulière avant et après l&#39;exécution de chacune des fonctions, ou transmettre un paramètre supplémentaire, ou convertir la sortie dans un autre format. . Nous pouvons également avoir de bonnes raisons de ne pas écrire la modification dans toutes les fonctions, peut-être que cela rendrait les définitions de fonction très verbeuses et lourdes, et peut-être que nous aimerions avoir la possibilité d&#39;appliquer la modification rapidement et facilement à n&#39;importe quelle fonction (et la supprimer simplement aussi facilement). . Pour résoudre ce problème, nous pouvons écrire une fonction qui modifie les fonctions. Nous appelons une fonction comme celle-ci un décorateur. Notre fonction prendra un objet de fonction comme paramètre et renverra un nouvel objet de fonction - nous pouvons alors affecter la nouvelle valeur de fonction au nom de l&#39;ancienne fonction pour remplacer l&#39;ancienne fonction par la nouvelle fonction. Par exemple, voici un décorateur qui enregistre le nom de la fonction et ses arguments dans un fichier journal chaque fois que la fonction est utilisée : . def log(original_function): def new_function(*args, **kwargs): with open(&quot;log.txt&quot;, &quot;w&quot;) as logfile: logfile.write(f&quot;Function &#39;{original_function.__name__}&#39; called with positional arguments {args} and keyword arguments {kwargs}. n&quot;) return original_function(*args, **kwargs) return new_function # here is a function to decorate def my_function(message): print(message) # and here is how we decorate it my_function = log(my_function) # Better decorating directly on its definition @log def my_function(message): print(message) . Nous pouvons passer des paramètres supplémentaires à notre décorateur. Par exemple, nous pouvons souhaiter spécifier un fichier journal personnalisé à utiliser dans notre décorateur de journalisation : . def log(original_function, logfilename=&quot;log.txt&quot;): def new_function(*args, **kwargs): with open(logfilename, &quot;w&quot;) as logfile: logfile.write(&quot;Function &#39;%s&#39; called with positional arguments %s and keyword arguments %s. n&quot; % (original_function.__name__, args, kwargs)) return original_function(*args, **kwargs) return new_function @log(&quot;someotherfilename.txt&quot;) def my_function(message): print(message) . 10. Les fonctions Lambda . Nous avons déjà vu que lorsque nous voulons utiliser un nombre ou une chaîne dans notre programme, nous pouvons soit l&#39;écrire sous forme de littéral à l&#39;endroit où nous voulons l&#39;utiliser, soit utiliser une variable que nous avons déjà définie dans notre code. Par exemple, print(&quot;Hello!&quot;) affiche la chaîne littérale &quot;Hello!&quot;, que nous n&#39;avons stockée nulle part dans une variable, mais print(message) affiche la chaîne stockée dans la variable message. . Nous avons aussi vu que l&#39;on peut stocker une fonction dans une variable, comme n&#39;importe quel autre objet, en s&#39;y référant par son nom (mais sans l&#39;appeler). Existe-t-il un littéral de fonction ? Peut-on définir une fonction à la volée lorsqu&#39;on veut la passer en paramètre ou l&#39;affecter à une variable, comme on l&#39;a fait avec la chaîne &quot;Bonjour !&quot; ? . La réponse est oui, mais uniquement pour des fonctions très simples. Nous pouvons utiliser le mot-clé lambda pour définir des fonctions anonymes sur une ligne dans notre code : . a = lambda: 3 # is the same as def a(): return 3 . Les lambdas peuvent prendre des paramètres, ils sont écrits entre le mot-clé lambda et les deux points, sans crochets. Une fonction lambda ne peut contenir qu&#39;une seule expression, et le résultat de l&#39;évaluation de cette expression est implicitement renvoyé par la fonction (nous n&#39;utilisons pas le mot-clé return) : . b = lambda x, y: x + y # is the same as def b(x, y): return x + y . Exercice 7 . 1) Définissez les fonctions suivantes comme lambdas et affectez-les à des variables : . - Prenez un paramètre, retourner son carré - Prenez deux paramètres, renvoie la racine carrée des sommes de leurs carrés - Prenez n&#39;importe quel nombre de paramètres, retourner leur moyenne - Prenez un paramètre de chaîne, renvoie une chaîne qui contient les lettres uniques dans la chaîne d&#39;entrée (dans n&#39;importe quel ordre) . | 2) Réécrivez toutes ces fonctions en tant que fonctions nommées. . | . 11. G&#233;n&#233;rateur (yield) . Nous avons déjà rencontré des générateurs, des séquences dans lesquelles de nouveaux éléments sont générés au fur et à mesure qu&#39;ils sont nécessaires, au lieu d&#39;être tous générés à l&#39;avance. Nous pouvons créer nos propres générateurs en écrivant des fonctions qui utilisent l&#39;instruction yield. . Considérez cette fonction simple qui renvoie une plage de nombres sous forme de liste : . def my_list(n): i = 0 l = [] while i &lt; n: l.append(i) i += 1 return l . Cette fonction construit la liste complète des nombres et la renvoie. On peut transformer cette fonction en fonction générateur tout en conservant une syntaxe très similaire, comme celle-ci : . def my_gen(n): i = 0 while i &lt; n: yield i i += 1 . La première chose importante à savoir sur l&#39;instruction yield est que si nous l&#39;utilisons dans une fonction, cette fonction renverra un générateur. Nous pouvons tester cela en utilisant la fonction type sur la valeur de retour de my_gen. Nous pouvons également essayer de l&#39;utiliser dans une boucle for, comme nous utiliserions n&#39;importe quel autre générateur, pour voir quelle séquence le générateur représente : . g = my_gen(3) print(type(g)) for x in g: print(x) . Exercice 8 . Écrivez une fonction génératrice qui prend un entier n comme paramètre. La fonction doit renvoyer un générateur qui compte à rebours de n à 0. Testez votre fonction en utilisant une boucle for. .",
            "url": "https://axi-technologies.github.io/AXI-Fastpages/python-intro-gen/chapter/5/lesson/1/",
            "relUrl": "/python-intro-gen/chapter/5/lesson/1/",
            "date": " • Jan 2, 2022"
        }
        
    
  
    
        ,"post3": {
            "title": "Chapitre 4 : Les exceptions",
            "content": "1. Les types des erreurs . Les erreurs ou les exceptions dans un programme sont souvent appelées bugs. Ils sont presque toujours la faute du programmeur. Le processus de recherche et d&#39;élimination des erreurs est appelé débuggage. Les erreurs peuvent être classées en trois grands groupes : . Erreurs de syntaxe | Erreurs d&#39;exécution | Erreurs logiques | . Les erreurs de syntaxe (SyntaxError) . Python trouvera ce genre d&#39;erreurs lorsqu&#39;il essaiera d&#39;analyser votre programme et se terminera avec un message d&#39;erreur sans rien exécuter. Les erreurs de syntaxe sont des erreurs dans l&#39;utilisation du langage Python, et sont analogues aux fautes d&#39;orthographe ou de grammaire dans une langue comme le français : par exemple, la phrase Vous du thé ?, n&#39;a pas de sens, il manque un verbe. . Les erreurs de syntaxe Python courantes incluent : . omettre un mot-clé | mettre un mot-clé au mauvais endroit | omettre un symbole, comme un deux-points, une virgule ou des crochets | faute d&#39;orthographe d&#39;un mot-clé | indentation incorrecte | bloc videil est interdit pour tout bloc (comme un corps if, ou le corps d&#39;une fonction) d&#39;être laissé complètement vide. Si vous voulez qu&#39;un bloc ne fasse rien, vous pouvez utiliser l&#39;instruction pass à l&#39;intérieur du bloc. . | . Python fera de son mieux pour vous dire où se trouve l&#39;erreur, mais parfois ses messages peuvent être trompeurs :par exemple, si vous oubliez d&#39;échapper un guillemet à l&#39;intérieur d&#39;une chaîne, vous pouvez obtenir une erreur de syntaxe faisant référence à un endroit plus loin dans votre code, même si ce n&#39;est pas la vraie source du problème. Si vous ne voyez rien de mal sur la ligne spécifiée dans le message d&#39;erreur, essayez de revenir en arrière sur les quelques lignes précédentes. Au fur et à mesure que vous programmez, vous vous améliorerez dans l&#39;identification et la correction des erreurs. Voici quelques erreurs de syntaxe : . myfunction(x, y): return x + y else: print(&quot;Hello!&quot;) if mark &gt;= 50 print(&quot;You passed!&quot;) if arriving: print(&quot;Hi!&quot;) esle: print(&quot;Bye!&quot;) if flag: print(&quot;Flag is set!&quot;) . File &#34;/tmp/ipykernel_11215/2942671249.py&#34;, line 1 myfunction(x, y): ^ SyntaxError: invalid syntax . Les erreurs d&#39;ex&#233;cution . Si un programme est syntaxiquement correct, c&#39;est-à-dire exempt d&#39;erreurs de syntaxe, il sera exécuté par l&#39;interpréteur Python. Cependant, le programme peut se fermer de manière inattendue pendant l&#39;exécution s&#39;il rencontre une erreur d&#39;exécution, un problème qui n&#39;a pas été détecté lors de l&#39;analyse du programme, mais qui n&#39;est révélé que lorsqu&#39;une ligne particulière est exécutée. Lorsqu&#39;un programme s&#39;arrête à cause d&#39;une erreur d&#39;exécution, nous disons qu&#39;il a planté. . Considérez les instructions en français : battez les bras et envolez-vous pour l&#39;Australie. Bien que l&#39;instruction soit structurellement correcte et que vous puissiez parfaitement comprendre sa signification, il vous est impossible de la suivre. . Quelques exemples d&#39;erreurs d&#39;exécution Python : . division par zéro | effectuer une opération sur des types incompatibles | utilisant un identifiant qui n&#39;a pas été défini | accéder à un élément de liste, une valeur de dictionnaire ou un attribut d&#39;objet qui n&#39;existe pas | essayer d&#39;accéder à un fichier qui n&#39;existe pas | . Des erreurs d&#39;exécution se glissent souvent si vous ne prenez pas en compte toutes les valeurs possibles qu&#39;une variable pourrait contenir, en particulier lorsque vous traitez une entrée utilisateur. Vous devriez toujours essayer d&#39;ajouter des vérifications à votre code pour vous assurer qu&#39;il peut traiter les mauvaises entrées et les cas extrêmes avec élégance. Nous verrons cela plus en détail dans le chapitre sur la gestion des exceptions. . Les erreurs logiques . Les erreurs logiques sont les plus difficiles à corriger. Elles se produisent lorsque le programme s&#39;exécute sans plantage, mais produit un résultat incorrect. L&#39;erreur est causée par une erreur dans la logique du programme. Vous ne recevrez pas de message d&#39;erreur, car aucune erreur de syntaxe ou d&#39;exécution ne s&#39;est produite. Vous devrez trouver le problème par vous-même en examinant toutes les parties pertinentes de votre code - bien que certains outils puissent signaler un code suspect qui pourrait provoquer un comportement inattendu. . Parfois, il ne peut y avoir absolument rien de mal avec votre implémentation Python d&#39;un algorithme, l&#39;algorithme lui-même peut être incorrect. Cependant, le plus souvent, ces types d&#39;erreurs sont causés par la négligence du programmeur. Voici quelques exemples d&#39;erreurs qui conduisent à des erreurs logiques : . utiliser le mauvais nom de variable | indentation d&#39;un bloc au mauvais niveau | utiliser la division entière au lieu de la division à virgule flottante | se tromper de priorité d&#39;opérateur | se tromper dans une expression booléenne | . Si vous orthographiez mal un nom d&#39;identifiant, vous pouvez obtenir une erreur d&#39;exécution ou une erreur logique, selon que le nom mal orthographié soit défini ou non. . Une source courante de confusion de noms de variables et d&#39;indentation incorrecte est la copie et le collage fréquents de gros blocs de code. Si vous avez de nombreuses lignes en double avec des différences mineures, il est très facile de rater une modification nécessaire lorsque vous modifiez vos lignes collées. Vous devriez toujours essayer d&#39;éliminer les doublons excessifs à l&#39;aide de fonctions et de boucles. . Exercice 1 . 1) Trouvez toutes les erreurs de syntaxe dans l&#39;extrait de code ci-dessus (dans la partie erreurs de syntaxe) et expliquez pourquoi ce sont des erreurs. | 2) Trouvez des sources potentielles d&#39;erreurs d&#39;exécution dans cet extrait de code : | . dividend = float(input(&quot;Please enter the dividend: &quot;)) divisor = float(input(&quot;Please enter the divisor: &quot;)) quotient = dividend / divisor quotient_rounded = math.round(quotient) . 3) Trouvez des sources potentielles d&#39;erreurs d&#39;exécution dans cet extrait de code : | . for x in range(a, b): c, d, e = my_list[x] print(f&quot;({c}, {d}, {e})&quot;) . 4) Trouvez des sources potentielles d&#39;erreurs logiques dans cet extrait de code : | . product = 0 for i in range(10): product *= i sum_squares = 0 for i in range(10): i_sq = i**2 sum_squares += i_sq nums = 0 for num in range(10): num += num . 2. La gestion des exceptions . Jusqu&#39;à présent, les programmes que nous avons écrits ont généralement ignoré le fait que les choses peuvent mal tourner. Nous avons essayé d&#39;éviter les erreurs d&#39;exécution en vérifiant les données qui peuvent être incorrectes avant de les utiliser, mais nous n&#39;avons pas encore vu comment nous pouvons gérer les erreurs lorsqu&#39;elles se produisent. Jusqu&#39;à présent, nos programmes ont crashé soudainement chaque fois qu&#39;ils en ont rencontré une. . Dans certaines situations, des erreurs d&#39;exécution sont susceptibles de se produire. Chaque fois que nous essayons de lire un fichier ou d&#39;obtenir des informations d&#39;un utilisateur, il est possible que quelque chose d&#39;inattendu se produise : le fichier peut avoir été déplacé ou supprimé, ou l&#39;utilisateur peut saisir des données qui ne sont pas au bon format. Les bons programmeurs devraient ajouter des garde-fous à leurs programmes afin que des situations courantes comme celle-ci puissent être gérées avec élégance. Un programme qui plante chaque fois qu&#39;il rencontre un problème facilement prévisible n&#39;est pas très agréable à utiliser. La plupart des utilisateurs s&#39;attendent à ce que les programmes soient suffisamment robustes pour se remettre de ce genre de revers. . Si nous savons qu&#39;une section particulière de notre programme est susceptible de provoquer une erreur, nous pouvons dire à Python quoi faire si cela se produit. Au lieu de laisser l&#39;erreur planter notre programme, nous pouvons l&#39;intercepter, faire quelque chose et permettre au programme de continuer. . Toutes les erreurs d&#39;exécution (et de syntaxe) que nous avons rencontrées sont appelées exception en Python. Python les utilise pour indiquer que quelque chose d&#39;exceptionnel s&#39;est produit et que votre programme ne peut pas continuer à moins qu&#39;il ne soit géré. Toutes les exceptions sont des sous-classes de la classe Exception, nous en apprendrons plus sur les classes et sur la façon d&#39;écrire vos propres types d&#39;exceptions dans les chapitres suivants. . Les instructions : try/except . Pour gérer les exceptions possibles, nous utilisons un bloc try/except : . try: age = int(input(&quot;Please enter your age: &quot;)) print(&quot;I see that you are %d years old.&quot; % age) except ValueError: print(&quot;Hey, that wasn&#39;t a number!&quot;) . Python essaiera de traiter toutes les instructions à l&#39;intérieur du bloc try. Si une ValueError se produit à tout moment pendant son exécution, le flux de contrôle passera immédiatement au bloc except et toutes les instructions restantes dans le bloc try seront ignorées. . Dans cet exemple, nous savons que l&#39;erreur est susceptible de se produire lorsque nous essayons de convertir l&#39;entrée de l&#39;utilisateur en un entier. Si la chaîne d&#39;entrée n&#39;est pas un nombre, cette ligne déclenchera une ValueError : c&#39;est pourquoi nous l&#39;avons spécifié comme le type d&#39;erreur que nous allons gérer. . Nous aurions pu spécifier un type d&#39;erreur plus général ou même laisser le type complètement de côté, ce qui aurait fait que la clause except correspondrait à n&#39;importe quel type d&#39;exception, mais cela aurait été une mauvaise idée. Et si nous obtenions une erreur complètement différente que nous n&#39;avions pas prévue ? Cela serait également traité, et nous ne remarquerions même pas que quelque chose d&#39;inhabituel allait mal. Nous pouvons également vouloir réagir de différentes manières à différents types d&#39;erreurs. Nous devrions toujours essayer de choisir des types d&#39;erreur spécifiques plutôt que généraux pour nos clauses except. . Il est possible pour une clause except de gérer plus d&#39;un type d&#39;erreur : nous pouvons fournir un tuple de types d&#39;exception au lieu d&#39;un seul type : . try: dividend = int(input(&quot;Please enter the dividend: &quot;)) divisor = int(input(&quot;Please enter the divisor: &quot;)) print(f&quot;{dividend} / {divisor} = {dividend/divisor}&quot;) except(ValueError, ZeroDivisionError): print(&quot;Oops, something went wrong!&quot;) . Un bloc try/except peut également avoir plusieurs clauses except. Si une exception se produit, Python vérifiera chaque clause except de haut en bas pour voir si le type d&#39;exception correspond. Si aucune des clauses except ne correspond, l&#39;exception sera considérée comme non gérée et votre programme plantera : . try: dividend = int(input(&quot;Please enter the dividend: &quot;)) divisor = int(input(&quot;Please enter the divisor: &quot;)) print(&quot;%d / %d = %f&quot; % (dividend, divisor, dividend/divisor)) except ValueError: print(&quot;The divisor and dividend have to be numbers!&quot;) except ZeroDivisionError: print(&quot;The dividend may not be zero!&quot;) . Notez que dans l&#39;exemple ci-dessus, si une ValueError se produit, nous ne saurons pas si cela a été causé par le dividende ou le diviseur (qui n&#39;est pas un entier), l&#39;une ou l&#39;autre des lignes d&#39;entrée pourrait provoquer cette erreur. Si nous voulons donner à l&#39;utilisateur un retour plus précis sur l&#39;entrée erronée, nous devrons envelopper chaque ligne d&#39;entrée dans un bloc try-except séparé : . try: dividend = int(input(&quot;Please enter the dividend: &quot;)) except ValueError: print(&quot;The dividend has to be a number!&quot;) try: divisor = int(input(&quot;Please enter the divisor: &quot;)) except ValueError: print(&quot;The divisor has to be a number!&quot;) try: print(&quot;%d / %d = %f&quot; % (dividend, divisor, dividend/divisor)) except ZeroDivisionError: print(&quot;The dividend may not be zero!&quot;) . Comment une exception est g&#233;r&#233;e . Lorsqu&#39;une exception se produit, le flux normal d&#39;exécution est interrompu. Python vérifie si la ligne de code qui a causé l&#39;exception se trouve à l&#39;intérieur d&#39;un bloc try/except. Si c&#39;est le cas, il vérifie si l&#39;un des blocs except associés au bloc try peut gérer ce type d&#39;exception. Si un gestionnaire approprié est trouvé, l&#39;exception est gérée et le programme continue à partir de l&#39;instruction suivante après la fin de ce try/except. . S&#39;il n&#39;y a pas de tel gestionnaire, ou si la ligne de code n&#39;était pas dans un bloc try, Python montera d&#39;un niveau de portée : si la ligne de code qui a causé l&#39;exception était à l&#39;intérieur d&#39;une fonction, cette fonction se terminera immédiatement, et la ligne qui a appelé la fonction sera traitée comme si elle avait levé l&#39;exception. Python vérifiera si cette ligne est à l&#39;intérieur d&#39;un bloc try, et ainsi de suite. Lorsqu&#39;une fonction est appelée, elle est placée sur la pile de Python, dont nous parlerons dans le chapitre sur les fonctions. Python parcourt cette pile lorsqu&#39;il essaie de gérer une exception. . Si une exception est levée par une ligne qui se trouve dans le corps principal de votre programme, pas à l&#39;intérieur d&#39;une fonction, le programme se terminera. Lorsque le message d&#39;exception est affiché, vous devriez également voir une trace : une liste qui montre le chemin emprunté par l&#39;exception, jusqu&#39;à la ligne d&#39;origine qui a causé l&#39;erreur. . La gestion des exceptions nous offre un autre moyen de gérer les situations sujettes aux erreurs dans notre code. Au lieu d&#39;effectuer plus de vérifications avant de faire quelque chose pour nous assurer qu&#39;une erreur ne se produira pas, nous essayons simplement de le faire et si une erreur se produit, nous la traitons. Cela peut nous permettre d&#39;écrire du code plus simple et plus lisible. Regardons un exemple d&#39;entrée plus compliqué : un dans lequel nous voulons continuer à demander à l&#39;utilisateur d&#39;entrer jusqu&#39;à ce que l&#39;entrée soit correcte. Nous allons essayer d&#39;écrire cet exemple en utilisant les deux approches différentes : . n = None while n is None: s = input(&quot;Please enter an integer: &quot;) if s.lstrip(&#39;-&#39;).isdigit(): n = int(s) else: print(&quot;%s is not an integer.&quot; % s) # with exception handling n = None while n is None: try: s = input(&quot;Please enter an integer: &quot;) n = int(s) except ValueError: print(&quot;%s is not an integer.&quot; % s) . Les avantages de la gestion des exceptions . Il sépare le code normal du code qui gère les erreurs. | Les exceptions peuvent facilement être transmises aux fonctions de la pile jusqu&#39;à ce qu&#39;elles atteignent une fonction qui sache comment les gérer. Les fonctions intermédiaires n&#39;ont pas besoin d&#39;avoir de code de gestion des erreurs. | Les exceptions sont livrées avec de nombreuses informations d&#39;erreur utiles intégrées - par exemple, elles peuvent imprimer un retraçage qui nous aide à voir exactement où l&#39;erreur s&#39;est produite. | . Les instructions else et finally . Il y a deux autres clauses que nous pouvons ajouter à un bloc try/except : else et finally. else ne sera exécuté que si la clause try ne lève pas d&#39;exception : . try: age = int(input(&quot;Please enter your age: &quot;)) except ValueError: print(&quot;Hey, that wasn&#39;t a number!&quot;) else: print(&quot;I see that you are %d years old.&quot; % age) . Nous voulons afficher un message sur l&#39;âge de l&#39;utilisateur uniquement si la conversion d&#39;entier réussit. Dans le premier exemple de gestionnaire d&#39;exceptions, nous plaçons cette instruction print directement après la conversion à l&#39;intérieur du bloc try. Dans les deux cas, l&#39;instruction ne sera exécutée que si l&#39;instruction de conversion ne lève pas d&#39;exception, mais la placer dans le bloc else est une meilleure pratique : cela signifie que le seul code à l&#39;intérieur du bloc try est la seule ligne qui est le potentiel source de l&#39;erreur que nous voulons traiter. . La clause finally sera exécutée à la fin du bloc try/except quoi qu&#39;il arrive : . s&#39;il n&#39;y a pas d&#39;exception | si une exception est levée et gérée, | si une exception est levée et non gérée Nous pouvons utiliser la clause finally pour le code de nettoyage que nous voulons toujours exécuter : | . try: age = int(input(&quot;Please enter your age: &quot;)) except ValueError: print(&quot;Hey, that wasn&#39;t a number!&quot;) else: print(&quot;I see that you are %d years old.&quot; % age) finally: print(&quot;It was really nice talking to you. Goodbye!&quot;) . Exercice 2 . 1) Étendez le programme de l&#39;exercice 7 du chapitre sur les boucles pour y inclure la gestion des exceptions. Chaque fois que l&#39;utilisateur entre une entrée de type incorrect, continuez à demander à l&#39;utilisateur la même valeur jusqu&#39;à ce qu&#39;elle soit entrée correctement. | . L&#39;instruction as . Les objets d&#39;exception de Python contiennent plus d&#39;informations que le type d&#39;erreur. Ils sont également accompagnés d&#39;une sorte de message, nous avons déjà vu certains de ces messages s&#39;afficher lorsque nos programmes se sont écrasés. Souvent, ces messages ne sont pas très conviviaux : si nous voulons signaler une erreur à l&#39;utilisateur, nous devons généralement écrire un message plus descriptif qui explique comment l&#39;erreur est liée à ce que l&#39;utilisateur a fait. Par exemple, si l&#39;erreur a été causée par une entrée incorrecte, il est utile d&#39;indiquer à l&#39;utilisateur laquelle des valeurs d&#39;entrée est incorrecte. . Parfois, le message d&#39;exception contient des informations utiles que nous souhaitons afficher à l&#39;utilisateur. Pour accéder au message, nous devons pouvoir accéder à l&#39;objet exception. Nous pouvons affecter l&#39;objet à une variable que nous pouvons utiliser dans la clause except comme ceci : . try: age = int(input(&quot;Please enter your age: &quot;)) except ValueError as err: print(err) . err n&#39;est pas une string, mais Python sait comment la convertir. La représentation sous forme de string d&#39;une exception est le message, ce qui est exactement ce que nous voulons. Nous pouvons également combiner le message d&#39;exception avec notre propre message : . try: age = int(input(&quot;Please enter your age: &quot;)) except ValueError as err: print(f&quot;You entered incorrect age input: &quot;{err} &quot;&quot;) . Lever des exceptions . Nous pouvons lever des exceptions nous-mêmes en utilisant l&#39;instruction raise : . try: age = int(input(&quot;Please enter your age: &quot;)) if age &lt; 0: raise ValueError(&quot;%d is not a valid age. Age must be positive or zero.&quot;) except ValueError as err: print(&quot;You entered incorrect age input: %s&quot; % err) else: print(&quot;I see that you are %d years old.&quot; % age) . Nous pouvons lever notre propre ValueError si l&#39;entrée age est un entier valide, mais elle est négative. Lorsque nous faisons cela, cela a exactement le même effet que toute autre exception, le flux de contrôle quittera immédiatement la clause try à ce stade et passera à la clause except. Cette clause except peut également correspondre à notre exception, car il s&#39;agit également d&#39;une ValueError. . Nous avons choisi ValueError comme type d&#39;exception car c&#39;est le plus approprié pour ce type d&#39;erreur. Rien ne nous empêche d&#39;utiliser une classe d&#39;exception complètement inappropriée ici, mais nous devons essayer d&#39;être cohérents. Voici quelques types d&#39;exceptions courants que nous sommes susceptibles de générer dans notre propre code : . 1) TypeError: c&#39;est une erreur qui indique qu&#39;une variable a le mauvais type pour une opération. Nous pouvons l&#39;augmenter dans une fonction si un paramètre n&#39;est pas d&#39;un type que nous savons gérer. | 2) ValueError: cette erreur est utilisée pour indiquer qu&#39;une variable a le bon type mais la mauvaise valeur. Par exemple, nous l&#39;avons utilisé lorsque l&#39;âge était un entier, mais le mauvais type d&#39;entier. | 3) NotImplementedError: nous verrons dans le chapitre suivant comment nous utilisons cette exception pour indiquer qu&#39;une méthode de classe doit être implémentée dans une classe enfant. | . Nous pouvons également écrire nos propres classes d&#39;exceptions personnalisées basées sur des classes d&#39;exceptions existantes. . Quelque chose que nous pouvons vouloir faire est de lever une exception que nous venons d&#39;intercepter, peut-être parce que nous voulons la gérer partiellement dans la fonction actuelle, mais aussi pour y répondre dans le code qui a appelé la fonction : . try: age = int(input(&quot;Please enter your age: &quot;)) except ValueError as err: print(&quot;You entered incorrect age input: %s&quot; % err) raise err . Exercice 3 . 1) Réécrivez le programme de la première question de l&#39;exercice 2 afin qu&#39;il affiche le texte de l&#39;exception originale de Python à l&#39;intérieur de la clause except au lieu d&#39;un message personnalisé. | 2) Réécrivez le programme à partir de la deuxième question de l&#39;exercice 2 de sorte que l&#39;exception qui est interceptée dans la clause except soit relancée après l&#39;impression du message d&#39;erreur. | . 3. D&#233;bugger le code . Les erreurs de syntaxe sont généralement assez simples à débugger : le message d&#39;erreur nous montre la ligne du fichier où se trouve l&#39;erreur, et il devrait être facile de la trouver et de la corriger. . Les erreurs d&#39;exécution peuvent être un peu plus difficiles à débugger : le message d&#39;erreur et le traceback peuvent nous dire exactement où l&#39;erreur s&#39;est produite, mais cela ne nous dit pas nécessairement quel est le problème. Parfois, ils sont causés par quelque chose d&#39;évident, comme un nom d&#39;identifiant incorrect, mais parfois ils sont déclenchés par un état particulier du programme : il n&#39;est pas toujours clair lequel des nombreuses variables a une valeur inattendue. . Les erreurs logiques sont les plus difficiles à corriger car elles ne provoquent aucune erreur pouvant être attribuée à une ligne particulière du code. Tout ce que nous savons, c&#39;est que le code ne se comporte pas comme il devrait l&#39;être. Parfois, la recherche de la zone du code à l&#39;origine du comportement incorrect peut prendre beaucoup de temps. . Il est important de tester votre code pour vous assurer qu&#39;il se comporte comme vous l&#39;attendez. Un moyen simple et rapide de tester qu&#39;une fonction fait ce qu&#39;il faut, par exemple, consiste à insérer une instruction print après chaque ligne qui renvoie les résultats intermédiaires qui ont été calculés sur cette ligne. La plupart des programmeurs le font intuitivement lorsqu&#39;ils écrivent une fonction, ou peut-être s&#39;ils ont besoin de comprendre pourquoi elle ne fait pas la bonne chose : . def hypotenuse(x, y): print(&quot;x is %f and y is %f&quot; % (x, y)) x_2 = x**2 print(x_2) y_2 = y**2 print(y_2) z_2 = x_2 + y_2 print(z_2) z = math.sqrt(z_2) print(z) return z . C&#39;est une chose rapide et facile à faire, et même les programmeurs expérimentés sont coupables de le faire de temps en temps, mais cette approche présente plusieurs inconvénients : . 1) Dès que la fonction fonctionne, nous sommes susceptibles de supprimer toutes les instructions d&#39;impression, car nous ne voulons pas que notre programme affiche toutes ces informations de débuggage tout le temps. Le problème est que le code change souvent, la prochaine fois que nous voulons tester cette fonction, nous devrons ajouter à nouveau les instructions print. | 2) Pour éviter de réécrire les instructions print si nous en avons à nouveau besoin, nous pouvons être tentés de les commenter au lieu de les supprimer. Les laissant encombrer notre code et éventuellement devenir tellement désynchronisés qu&#39;ils finissent par être complètement inutiles de toute façon . | 3) Pour afficher toutes ces valeurs intermédiaires, nous avons dû étaler la formule à l&#39;intérieur de la fonction sur plusieurs lignes. Parfois, il est utile de diviser un calcul en plusieurs étapes, s&#39;il est très long et que tout mettre sur une seule ligne le rend difficile à lire, mais parfois cela rend simplement notre code inutilement verbeux. Voici à quoi ressemblerait normalement la fonction ci-dessus : | . def hypotenuse(x, y): return math.sqrt(x**2 + y**2) . Comment pouvons-nous mieux faire que ça ? Si nous voulons inspecter les valeurs des variables à différentes étapes de l&#39;exécution d&#39;un programme, nous pouvons utiliser un outil comme pdb (ou plutôt son évolution : ipdb si le package est installé). Si nous voulons que notre programme affiche des messages informatifs, éventuellement dans un fichier, et que nous voulons pouvoir contrôler le niveau de détail au moment de l&#39;exécution sans avoir à modifier quoi que ce soit dans le code, nous pouvons utiliser la journalisation. . Plus important encore, pour vérifier que notre code fonctionne correctement maintenant et continuera à fonctionner correctement, nous devons écrire une suite permanente de tests que nous pouvons exécuter régulièrement sur notre code. Nous discuterons plus en détail des tests dans un chapitre ultérieur. . pdb (ou ipdb) . pdb est un module Python intégré que nous pouvons utiliser pour débugger un programme pendant son exécution. Nous pouvons soit importer le module et utiliser ses fonctions depuis notre code, soit l&#39;invoquer en tant que script lors de l&#39;exécution de notre fichier de code. Nous pouvons utiliser pdb pour parcourir notre programme, ligne par ligne ou par incréments plus importants, inspecter l&#39;état à chaque étape et effectuer un &quot;post-mortem&quot; du programme s&#39;il plante. . import pdb try: age_str = input(&quot;Please enter your age: &quot;) age = int(age_str) except ValueError as err: pdb.set_trace() . Logging . Parfois, il est utile qu&#39;un programme envoie des messages à une console ou à un fichier pendant son exécution. Ces messages peuvent être utilisés comme enregistrement de l&#39;exécution du programme et nous aident à trouver des erreurs. Parfois, un bug se produit par intermittence et nous ne savons pas ce qui le déclenche, si nous ajoutons une sortie de débuggage à notre programme uniquement lorsque nous voulons commencer une recherche active du bug, nous ne pourrons peut-être pas le reproduire. Si notre programme enregistre les messages dans un fichier tout le temps, nous pouvons constater que des informations utiles ont été enregistrées lorsque nous vérifions le journal (logs) après que le bug se soit produit. . Certains types de messages sont plus importants que d&#39;autres, les erreurs sont des événements notables qui doivent presque toujours être enregistrés. Les messages qui enregistrent qu&#39;une opération s&#39;est terminée avec succès peuvent parfois être utiles, mais ne sont pas aussi importants que les erreurs. Des messages détaillés qui débuggent chaque étape d&#39;un calcul peuvent être intéressants si nous essayons de débugger le calcul, mais s&#39;ils étaient affichés tout le temps, ils rempliraient la console de bruit (ou rendraient notre fichier de logs vraiment, vraiment gros). . Nous pouvons utiliser le module de log de Python pour ajouter la journalisation à notre programme de manière simple et cohérente. Les instructions de log sont presque comme les instructions d&#39;affichage, mais chaque fois que nous enregistrons un message, nous spécifions un niveau pour le message. Lorsque nous exécutons notre programme, nous définissons un niveau de log souhaité pour le programme. Seuls les messages dont le niveau est supérieur ou égal au niveau que nous avons défini apparaîtront dans le journal. Cela signifie que nous pouvons temporairement activer la journalisation détaillée et la désactiver à nouveau en modifiant simplement le niveau de log à un seul endroit. . Il existe un ensemble cohérent de noms de niveau de log que la plupart des langues utilisent. Dans l&#39;ordre, de la valeur la plus élevée (la plus sévère) à la valeur la plus basse (la moins sévère), ce sont : . CRITICAL : pour les erreurs très graves | ERROR : pour les erreurs moins graves | WARNING : pour les avertissements | INFO : pour les messages informatifs importants | DEBUG : pour des messages de débuggage détaillés | . Ces noms sont utilisés pour les constantes entières définies dans le module de log : logging. Le module fournit également des méthodes que nous pouvons utiliser pour enregistrer les messages. Par défaut, ces messages sont affichés sur la console et le niveau de log par défaut est WARNING. Nous pouvons configurer le module pour personnaliser son comportement : par exemple, nous pouvons écrire les messages dans un fichier à la place, augmenter ou diminuer le niveau de log et modifier le format du message. Voici un exemple de journalisation simple : . import logging # log messages to a file, ignoring anything less severe than ERROR logging.basicConfig(filename=&#39;myprogram.log&#39;, level=logging.ERROR) # these messages should appear in our file logging.error(&quot;The washing machine is leaking!&quot;) logging.critical(&quot;The house is on fire!&quot;) # but these ones won&#39;t logging.warning(&quot;We&#39;re almost out of milk.&quot;) logging.info(&quot;It&#39;s sunny today.&quot;) logging.debug(&quot;I had eggs for breakfast.&quot;) .",
            "url": "https://axi-technologies.github.io/AXI-Fastpages/python-intro-gen/chapter/4/lesson/1/",
            "relUrl": "/python-intro-gen/chapter/4/lesson/1/",
            "date": " • Jan 2, 2022"
        }
        
    
  
    
        ,"post4": {
            "title": "Chapitre 3 : Les boucles",
            "content": "Dans ce chapitre, vous apprendrez comment faire en sorte que l&#39;ordinateur exécute un groupe d&#39;instructions encore et encore tant qu&#39;un certain critère est vérifié. Le groupe d&#39;instructions exécutées à plusieurs reprises est appelé une boucle. Il existe deux instructions de boucle en Python : for et while. Nous discuterons de la différence entre ces déclarations plus loin dans le chapitre, mais regardons d&#39;abord un exemple de boucle dans le monde réel. . Un employé d&#39;une station service effectue les actions suivantes lorsqu&#39;il sert un client : . 1) Saluer le client | 2) Demander le type d&#39;essence requis et la quantité | 3) Demander si le client a besoin d&#39;autres services | 4) Demander la somme d&#39;argent requise | 5) Donner de l&#39;argent au caissier | 6) Attendre le changement et la réception | 7) Remettre la monnaie et le reçu au client | 8) Dire merci et au revoir | . L&#39;employé effectue ces étapes pour chaque client, mais il ne les suit pas lorsqu&#39;il n&#39;y a pas de client à servir. Il ne les exécute également que lorsque lors de son temps de travail. Si nous devions écrire un programme informatique pour simuler ce comportement, il ne suffirait pas de fournir les étapes et de demander à l&#39;ordinateur de les répéter encore et encore. Nous aurions également besoin de lui dire quand arrêter de les exécuter. . Il existe deux grands types de boucles de programmation : les boucles de comptage (for) et les boucles contrôlées par événement (while). . Dans une boucle de comptage, l&#39;ordinateur sait au début de l&#39;exécution de la boucle combien de fois il doit exécuter la boucle. En Python, ce type de boucle est défini avec l&#39;instruction for, qui exécute le corps de la boucle pour chaque élément d&#39;une liste. . Dans une boucle contrôlées par événement, l&#39;ordinateur arrête l&#39;exécution de la boucle lorsqu&#39;une condition n&#39;est plus vraie. En Python, vous pouvez utiliser l&#39;instruction while. L&#39;ordinateur exécute le corps de la boucle tant que la condition est vraie. L&#39;instruction while vérifie la condition avant d&#39;effectuer chaque itération de la boucle. . Les boucles de comptage sont en fait un sous-ensemble de la boucle de contrôle d&#39;événement, la boucle est répétée jusqu&#39;à ce que le nombre requis d&#39;itérations soit atteint. . Si vous vouliez aller de Paris à Marseille, quel algorithme de boucle utiliseriez-vous ? Si vous avez commencé par mettre votre voiture sur la route de Marseille, vous pourriez : . Rouler exactement 7h30. Après 7h30, arréter la voiture et descendre. | Rouler exactement 780km. Après 780km, arréter la voiture et descendre. | Roulez tant que nous ne sommes pas arrivé à Marseille. Une fois arriver, arréter la voiture et descendre. | . Les deux premiers algorithmes sont basés sur le comptage, aucun de ces algorithmes ne garantit que vous arriverez à Marseille. Dans le premier cas, vous pourriez rencontrer un trafic dense ou pas du tout, et ne pas atteindre ou dépasser la destination souhaitée. Dans le second cas, vous pourriez trouver un détour et vous retrouver loin de Camps Bay. . Le troisième algorithme est contrôlé par les événements. Vous continuez à conduire tant que vous n&#39;êtes pas à Marseille. La condition que vous continuez à vérifier est : est-ce que je suis arrivé à Marseille ? . 1. La boucle while . L&#39;instruction python pour une boucle controlé par des évenements est : while. Vous devez l&#39;utiliser lorsque vous ne savez pas à l&#39;avance combien de fois vous devrez exécuter le corps de la boucle. Tant que la condition est vraie, le corps while continue de se répéter. Exemple : . total = 0 i = 1 while i &lt;=10: total += i i += 1 print(i, total) . La variable utilisée dans la condition de boucle est le nombre i, que vous utilisez pour compter les entiers de 1 à 10. Vous initialisez d&#39;abord ce nombre à 1. Dans la condition, vous vérifiez si i est inférieur ou égal à 10, et si c&#39;est vrai, vous exécutez le corps de la boucle. Ensuite, à la fin du corps de la boucle, vous mettez à jour i en l&#39;incrémentant de 1. . Il est très important que vous incrémentiez i à la fin. Sinon, i serait toujours égal à 1, la condition serait toujours vraie et votre programme ne se terminerait jamais. Nous appelons cela une boucle infinie. Chaque fois que vous écrivez une boucle while, assurez-vous que la variable que vous utilisez dans votre condition est mise à jour à l&#39;intérieur du corps de la boucle. . Voici quelques erreurs courantes pouvant entraîner une boucle infinie : . x = 0 while x &lt; 3: y += 1 # wrong variable updated product = 1 count = 1 while count &lt;= 10: product *= count # forgot to update count x = 0 while x &lt; 5: print(x) x += 1 # update statement is indented one level too little, so it&#39;s outside the loop body x = 0 while x != 5: print(x) x += 2 # x will never equal 5, because we are counting in even numbers! . Dans certains exemples ci-dessus, nous comptons jusqu&#39;à un nombre prédéterminé, il serait donc plus approprié pour nous d&#39;utiliser une boucle for, c&#39;est la structure de boucle qui est la plus couramment utilisée pour compter les boucles. Voici un exemple plus réaliste : . numbers = [23, 1, -2, 23, 9, 12] total = 0 i = 0 # while total &lt; 100: while i &lt; len(numbers) and total &lt; 100: total += numbers[i] i += 1 print(total) . Ici, nous additionnons les nombres d&#39;une liste jusqu&#39;à ce que le total atteigne 100. Nous ne savons pas combien de fois nous devrons exécuter la boucle, car nous ne connaissons pas les valeurs des nombres. Notez que nous pourrions atteindre la fin de la liste des nombres avant que le total n&#39;atteigne 100. Si nous essayons d&#39;accéder à un élément au-delà de la fin de la liste, nous obtiendrons une erreur, nous devons donc ajouter une vérification pour nous assurer que cela ne fonctionne pas. ça n&#39;arrive pas. . Exercice 1 : . 1) Écrivez un programme qui utilise une boucle while pour additionner les carrés d&#39;entiers (à partir de 1) jusqu&#39;à ce que le total dépasse 200. Affichez le total final et le dernier nombre à mettre au carré et ajouter. | 2) Ecrivez un programme qui demande à l&#39;utilisateur de deviner un mot. L&#39;utilisateur a jusqu&#39;à dix suppositions – écrivez votre code de telle sorte que le mot secret et le nombre de suppositions autorisées soient faciles à modifier. Affichez des messages pour donner votre avis à l&#39;utilisateur. | . 2. La boucle for . L&#39;instruction python pour une boucle de comptage est : for. Vous devriez l&#39;utiliser lorsque vous devez faire quelque chose pour un nombre prédéfini d&#39;étapes. . Exemple : . for i in range(1, 9): print(i) . Comme nous l&#39;avons vu dans le chapitre précédent, range est un type de séquence immuable utilisé pour générer des entiers. Dans ce cas, le range compte de 1 à 8. La boucle for parcourra chacun des nombres tour à tour , effectuant l&#39;action d&#39;affichage. Lorsque la fin du range est atteint, la boucle for se termine. . Vous pouvez également utiliser un for pour parcourir d&#39;autres types de séquences. Vous pouvez parcourir une liste de string comme celle-ci : . pets = [&quot;cat&quot;, &quot;dog&quot;, &quot;budgie&quot;] for pet in pets: print(pet) . A chaque itération de la boucle, l&#39;élément suivant de la liste pets est affecté à la variable pet, à laquelle vous pouvez alors accéder à l&#39;intérieur du corps de la boucle. L&#39;exemple ci-dessus est fonctionnellement identique à celui-ci : . for i in range(len(pets)): # i will iterate over 0, 1 and 2 pet = pets[i] print(pet) . Vous devriez éviter de faire cela, car c&#39;est plus difficile à lire et inutilement complexe. Si, pour une raison quelconque, vous avez besoin de l&#39;index à l&#39;intérieur de la boucle ainsi que de l&#39;élément de liste lui-même, vous pouvez utiliser la fonction enumerate pour numéroter les éléments : . for i, pet in enumerate(pets): pets[i] = pet.upper() # rewrite the list in all caps . Exercice 2 : . 1) Écrivez un programme qui additionne les nombres entiers de 1 à 10 en utilisant une boucle for (et affiche le total à la fin). | 2) Pouvez-vous penser à un moyen de le faire sans utiliser de boucle ? | 3) Écrire un programme qui trouve la factorielle d&#39;un nombre donné. Par exemple. 3 factoriel, ou 3! est égal à 3 x 2 x 1; 5! est égal à 5 ​​x 4 x 3 x 2 x 1, etc. Votre programme ne doit contenir qu&#39;une seule boucle. | 4) Écrivez un programme qui demande à l&#39;utilisateur 10 nombres à virgule flottante et calcule leur somme, leur produit et leur moyenne. Votre programme ne doit contenir qu&#39;une seule boucle. | 5) Réécrivez le programme précédent pour qu&#39;il ait deux boucles, une qui collecte et stocke les nombres, et une qui les traite. | . 3. Boucles imbriqu&#233;es . Nous avons vu dans le chapitre précédent que nous pouvons créer des séquences multidimensionnelles, des lesquelles chaque élément est une autre séquence. Comment itérer sur toutes les valeurs d&#39;une séquence multidimensionnelle ? Nous devons utiliser des boucles à l&#39;intérieur d&#39;autres boucles. Lorsque nous faisons cela, nous disons que nous imbriquons des boucles. . Ré-utilisons l&#39;exemple de l&#39;emploi du temps du chapitre précédent, nous avons une séquence multidimensionnelle qui contient sept jours et que chaque jour contient 24 plages horaires. Chaque créneau horaire est une chaîne, qui est vide s&#39;il n&#39;y a rien de prévu pour ce créneau. Comment itérer sur tous les créneaux horaires et afficher tous nos événements programmés ? . WEEKDAYS = (&#39;Monday&#39;, &#39;Tuesday&#39;, &#39;Wednesday&#39;, &#39;Thursday&#39;, &#39;Friday&#39;, &#39;Saturday&#39;, &#39;Sunday&#39;) # Create &amp; fill timetable timetable = [[&quot;&quot;] * 24 for day in range(7)] timetable[5][16] = &quot;Python lesson.&quot; # now we iterate over each day in the timetable for index_day, day in enumerate(timetable): # and over each timeslot in each day for hour, event in enumerate(day): if event: # if the slot is not an empty string print(f&quot;{WEEKDAYS[index_day]} at {hour}:00 -- {event}&quot;) . Exercice 3 . 1) Ecrivez un programme qui utilise une boucle for imbriquée pour remplir une liste tridimensionnelle représentant un calendrier : la liste de niveau supérieur doit contenir une sous-liste pour chaque mois, et chaque mois doit contenir quatre semaines. Chaque semaine doit être une liste vide. | 2) Modifiez votre code pour faciliter l&#39;accès à un mois dans le calendrier par un nom de mois lisible par l&#39;homme. Faire de même pour les semaines par un nom qui est numéroté à partir de 1. Ajoutez un événement (sous la forme d&#39;une chaîne de description) à la deuxième semaine de juillet. | . 4. It&#233;rables, it&#233;rateurs et g&#233;n&#233;rateurs . En Python, tout type qui peut être itéré avec une boucle for est un itérable. Les listes, les tuples, les string et les dictionnaires sont tous des types itérables couramment utilisés. Itérer sur une liste ou un tuple signifie simplement traiter chaque valeur à son tour. . Parfois, nous utilisons une séquence pour stocker une série de valeurs qui ne suivent aucun modèle particulier : chaque valeur est imprévisible et ne peut pas être calculée à la volée. Dans des cas comme celui-ci, nous n&#39;avons pas d&#39;autre choix que de stocker chaque valeur dans une liste ou un tuple. Si la liste est très longue, cela peut utiliser beaucoup de mémoire. . Que se passe-t-il si les valeurs de notre séquence suivent un modèle et peuvent être calculées à la volée ? Nous pouvons économiser beaucoup de mémoire en ne calculant les valeurs que lorsque nous en avons besoin, au lieu de toutes les calculer à l&#39;avance : au lieu de stocker une grande liste, nous pouvons stocker uniquement les informations dont nous avons besoin pour le calcul. . Python a beaucoup de types itérables intégrés qui génèrent des valeurs à la demande - ils sont souvent appelés générateurs. Nous avons déjà vu quelques exemples, comme range et enumerate. Vous pouvez principalement traiter un générateur comme n&#39;importe quelle autre séquence si vous n&#39;avez besoin d&#39;accéder qu&#39;à ses éléments un à la fois - par exemple, si vous l&#39;utilisez dans une boucle for : . for i in (1, 2, 3, 4, 5): print(i) for i in range(1, 6): print(i) . Vous remarquerez peut-être une différence si vous essayez d&#39;afficher le contenu du générateur, par défaut, tout ce que vous obtiendrez est la représentation sous forme standard de Python de l&#39;objet, qui vous montre le type de l&#39;objet et son identifiant unique. Pour afficher toutes les valeurs du générateur, nous devons le convertir en un type de séquence comme une liste, ce qui forcera toutes les valeurs à être générées : . print(range(100)) # this will show you all the generated values print(list(range(100))) . Vous pouvez utiliser tous ces itérables de manière presque interchangeable car ils utilisent tous la même interface pour itérer sur les valeurs : chaque objet itérable a une méthode qui peut être utilisée pour renvoyer un itérateur sur cet objet. L&#39;itérable et l&#39;itérateur forment ensemble une interface cohérente qui peut être utilisée pour parcourir une séquence de valeurs, que ces valeurs soient toutes stockées en mémoire ou calculées selon les besoins : . L&#39;itérable a une méthode pour accéder à un élément par son index. Par exemple, une liste renvoie simplement l&#39;élément qui est stocké dans une position particulière. Une plage, d&#39;autre part, calcule l&#39;entier dans la plage qui correspond à un indice particulier. . L&#39;itérateur garde l&#39;index de lecture dans la séquence et dispose d&#39;une méthode qui vous permet d&#39;accéder à l&#39;élément suivant. Il peut y avoir plusieurs itérateurs associés à un seul itérable en même temps. chacun à un endroit différent dans l&#39;itération. Par exemple, vous pouvez parcourir la même liste dans les deux niveaux d&#39;une boucle imbriquée - chaque boucle utilise son propre itérateur et elles n&#39;interfèrent pas les unes avec les autres : . numbers = [1, 2, 3] for a in numbers: for b in numbers: print(f&quot;{a} + {b} = {a + b}&quot;) . Quelques exemples de générateurs intégrés définis dans le module itertools de Python : . import itertools # unlike range, count doesn&#39;t have an upper bound, and is not restricted to integers for i in itertools.count(1): print(i) # 1, 2, 3.... for i in itertools.count(1, 0.5): print(i) # 1.0, 1.5, 2.0.... # cycle repeats the values in another iterable over and over for animal in itertools.cycle([&#39;cat&#39;, &#39;dog&#39;]): print(animal) # &#39;cat&#39;, &#39;dog&#39;, &#39;cat&#39;, &#39;dog&#39;... # repeat repeats a single item for i in itertools.repeat(1): # ...forever print(i) # 1, 1, 1.... for i in itertools.repeat(1, 3): # or a set number of times print(i) # 1, 1, 1 # chain combines multiple iterables sequentially for i in itertools.chain(numbers, animals): print(i) # print all the numbers and then all the animals . Il existe également une fonction intégrée appelée zip qui nous permet de combiner plusieurs itérables par paire. Il sort également un générateur : . for i in zip((1, 2, 3), (4, 5, 6)): print(i) for i in zip(range(5), range(5, 10), range(10, 15)): print(i) . Exercice 4 : . 1) Créez un tuple de noms de mois et un tuple du nombre de jours de chaque mois (supposez que février a 28 jours). En utilisant une seule boucle for, construisez un dictionnaire qui a les noms de mois comme clés et les numéros de jour correspondants comme valeurs. | 2) Faites maintenant la même chose sans utiliser de boucle for. | . 5. Les compr&#233;hensions . Supposons que nous ayons une liste de nombres et que nous voulions construire une nouvelle liste en doublant toutes les valeurs de la première liste. Ou que nous voulons extraire tous les nombres pairs d&#39;une liste de nombres. Ou que nous voulons trouver et mettre en majuscule tous les noms d&#39;animaux dans une liste de noms d&#39;animaux qui commencent par une voyelle. Nous pouvons faire chacune de ces choses en itérant sur la liste d&#39;origine, en effectuant une sorte de vérification sur chaque élément à tour de rôle et en ajoutant des valeurs à une nouvelle liste au fur et à mesure. . numbers = [1, 5, 2, 12, 14, 7, 18] doubles = [] for number in numbers: doubles.append(2 * number) even_numbers = [] for number in numbers: if number % 2 == 0: even_numbers.append(number) animals = [&#39;aardvark&#39;, &#39;cat&#39;, &#39;dog&#39;, &#39;opossum&#39;] vowel_animals = [] for animal in animals: if animal[0] in &#39;aeiou&#39;: vowel_animals.append(animal.title()) . C&#39;est une façon assez lourde de faire quelque chose de très simple. Heureusement, nous pouvons réécrire des boucles simples comme celle-ci pour utiliser une syntaxe plus propre et plus lisible en utilisant des compréhensions. . Une compréhension est une sorte de filtre que nous pouvons définir sur un itérable basé sur une certaine condition. Le résultat est un autre itérable. Voici quelques exemples de compréhensions de liste : . doubles = [2 * number for number in numbers] even_numbers = [number for number in numbers if number % 2 == 0] vowel_animals = [animal.title() for animal in animals if animal[0] in &#39;aeiou&#39;] . La compréhension est la partie écrite entre crochets sur chaque ligne. Chacune de ces compréhensions se traduit par la création d&#39;un nouvel objet liste. . Exercice 5 . 1) Créez une string qui contient les dix premiers entiers positifs séparés par des virgules et des espaces. N&#39;oubliez pas que vous ne pouvez pas joindre des nombres - vous devez d&#39;abord les convertir en string. Affichez la string. | 2) Réécrivez le programme calendaire de l&#39;exercice 3 en utilisant des compréhensions imbriquées au lieu de boucles imbriquées. Essayez d&#39;ajouter une chaîne à l&#39;une des listes de semaines, pour vous assurer que vous n&#39;avez pas réutilisé la même liste au lieu de créer une liste distincte pour chaque semaine. | 3) Faites maintenant quelque chose de similaire pour créer un calendrier qui est une liste avec 52 sous-listes vides (une pour chaque semaine de l&#39;année entière). Astuce : comment modifieriez-vous les boucles for imbriquées ? | . 6. Les instructions break et continue . L&#39;instruction break . À l&#39;intérieur du corps de la boucle, vous pouvez utiliser l&#39;instruction break pour quitter immédiatement la boucle. Vous voudrez peut-être tester un cas particulier qui entraînera une sortie immédiate de la boucle. Par exemple: . x = 1 while x &lt;= 10: if x == 5: break print(x) x += 1 . L&#39;instruction continue . L&#39;instruction continue est similaire à l&#39;instruction break, en ce sens qu&#39;elle fait sortir le flux de contrôle du corps de la boucle actuelle au point de rencontre, mais la boucle elle-même n&#39;est pas terminée. Par exemple: . for x in range(1, 10 + 1): # this will count from 1 to 10 if x == 5: continue print(x) . Exercice 6 . 1) Ecrivez un programme qui demande à plusieurs reprises à l&#39;utilisateur un nombre entier. Si l&#39;entier est pair, affichez le. Si l&#39;entier est impair, n&#39;affichez rien. Quittez le programme si l&#39;utilisateur entre l&#39;entier 99. . Certains programmes demandent à l&#39;utilisateur d&#39;entrer un nombre variable d&#39;entrées de données, et enfin d&#39;entrer un caractère ou une chaîne spécifique qui signifie qu&#39;il n&#39;y a plus d&#39;entrées. Par exemple, vous pourriez être invité à entrer votre code PIN suivi d&#39;un dièse (#). Le dièse indique que vous avez fini de saisir votre code PIN. . 2) Écrire un programme qui fait la moyenne des nombres entiers positifs. Votre programme doit inviter l&#39;utilisateur à entrer des entiers jusqu&#39;à ce que l&#39;utilisateur entre un entier négatif. L&#39;entier négatif doit être ignoré et vous devez imprimer la moyenne de tous les entiers précédemment entrés. . | 3) Implémentez une calculatrice simple avec un menu. Affichez les options suivantes à l&#39;utilisateur, demandez une sélection et effectuez l&#39;action demandée (par exemple, demandez deux chiffres et ajoutez-les). Après chaque opération, retournez l&#39;utilisateur au menu. Quittez le programme lorsque l&#39;utilisateur sélectionne 0. Si l&#39;utilisateur entre un nombre qui n&#39;est pas dans le menu, ignorez l&#39;entrée et réaffichez le menu. Vous pouvez supposer que l&#39;utilisateur entrera un entier valide : . | . | . -- Calculator Menu -- 0. Quit 1. Add two numbers 2. Substract two numbers 3. Multiple two numbers 4. Divide two numbers Utiliser des boucles pour simplifier le code . Nous pouvons utiliser notre connaissance des boucles pour simplifier certains types de code redondant. Considérons cet exemple, dans lequel nous demandons à un utilisateur quelques informations personnelles : . name = input(&quot;Please enter your name: &quot;) surname = input(&quot;Please enter your surname: &quot;) # let&#39;s store these as strings for now, and convert them to numbers later age = input(&quot;Please enter your age: &quot;) height = input(&quot;Please enter your height: &quot;) weight = input(&quot;Please enter your weight: &quot;) . person = {} for prop in [&quot;name&quot;, &quot;surname&quot;, &quot;age&quot;, &quot;height&quot;, &quot;weight&quot;]: person[prop] = input(&quot;Please enter your %s: &quot; % prop) . Exercice 7 . Modifiez l&#39;exemple ci-dessus pour inclure la conversion de type des propriétés : l&#39;âge doit être un nombre entier, la taille et le poids doivent être des nombres flottants, et le nom et le prénom doivent être des string. | .",
            "url": "https://axi-technologies.github.io/AXI-Fastpages/python-intro-gen/chapter/3/lesson/2/",
            "relUrl": "/python-intro-gen/chapter/3/lesson/2/",
            "date": " • Jan 2, 2022"
        }
        
    
  
    
        ,"post5": {
            "title": "Chapitre 3 : Les collections",
            "content": "Nous avons déjà rencontré quelques types Python simples comme les nombres (int, float), les string (str)et les booléens (bool). Nous allons maintenant voir comment regrouper plusieurs valeurs dans une collection, comme une liste de nombres ou un dictionnaire que nous pouvons utiliser pour stocker et récupérer des paires clé-valeur. De nombreuses collections utiles sont des types intégrés dans Python, et nous les rencontrerons assez souvent. . 1. Les listes (list) . Le type de liste en Python est appelé list. Nous pouvons l&#39;utiliser pour stocker plusieurs valeurs et y accéder séquentiellement ou par leur position (leur index). Les listes sont définis avec un ensemble de valeurs séparées par des virgules entre crochets ([ et ]) : . animals = [&#39;cat&#39;, &#39;dog&#39;, &#39;fish&#39;, &#39;bison&#39;] # a list of integers numbers = [1, 7, 34, 20, 12] # an empty list my_list = [] # a list of variables we defined somewhere else things = [ one_variable, another_variable, third_variable, # this trailing comma is legal in Python ] . Comme vous pouvez le voir, nous avons utilisé des noms au pluriel pour nommer la plupart de nos variables de liste. Il s&#39;agit d&#39;une convention courante et il est utile de la suivre dans la plupart des cas. . Pour accéder à un élément de la liste, nous utilisons l&#39;identifiant de la liste suivi de l&#39;index entre crochets. Les index sont des entiers qui commencent à zéro : . print(animals[0]) # cat print(numbers[1]) # 7 # This will give us an error, because the list only has four elements print(animals[6]) . On peut aussi retrouver des éléments en partant de la fin : . print(animals[-1]) # the last element -- bison print(numbers[-2]) # the second-last element -- 20 . Nous pouvons aussi extraire un sous-ensemble d&#39;une liste (qui sera elle-même une liste) à l&#39;aide d&#39;un slice. Cela utilise presque la même syntaxe que pour accéder à un seul élément, mais au lieu de spécifier un seul index entre les crochets, nous devons spécifier une limite supérieure et inférieure. Notez que notre sous-liste inclura l&#39;élément à la limite inférieure, mais exclura l&#39;élément à la limite supérieure : . print(animals[1:3]) # [&#39;dog&#39;, &#39;fish&#39;] print(animals[1:-1]) # [&#39;dog&#39;, &#39;fish&#39;] . Si l&#39;une des limites est l&#39;une des extrémités de la liste, nous pouvons la laisser de côté. . print(animals[2:]) # [&#39;fish&#39;, &#39;bison&#39;] print(animals[:2]) # [&#39;cat&#39;, &#39;dog&#39;] print(animals[:]) # a copy of the whole list . Nous pouvons même inclure un troisième paramètre pour spécifier la taille du pas : . print(animals[::2]) # [&#39;cat&#39;, &#39;fish&#39;] . Les listes sont mutables, nous pouvons modifier des éléments, en ajouter ou en supprimer. Une liste changera de taille automatiquement lorsque nous ajoutons ou supprimons des éléments : . animals[3] = &quot;hamster&quot; # add a new element to the end of the list animals.append(&quot;squirrel&quot;) # remove an element by its index del animals[2] . Comme les list sont mutables, nous pouvons modifier une variable d&#39;une list sans lui affecter une valeur complètement nouvelle. N&#39;oubliez pas que si nous attribuons la même valeur de list à deux variables, toute modification faite à l&#39;une des deux variables sera refleté sur l&#39;autre : . animals = [&#39;cat&#39;, &#39;dog&#39;, &#39;goldfish&#39;, &#39;canary&#39;] pets = animals # now both variables refer to the same list object animals.append(&#39;aardvark&#39;) print(pets) # pets is still the same list as animals animals = [&#39;rat&#39;, &#39;gerbil&#39;, &#39;hamster&#39;] # now we assign a new list value to animals print(pets) # pets still refers to the old list pets = animals[:] # assign a *copy* of animals to pets animals.append(&#39;aardvark&#39;) print(pets) # pets remains unchanged, because it refers to a copy, not the original list . On peut mélanger les types de valeurs que l&#39;on stocke dans une liste : . my_list = [&#39;cat&#39;, 12, 35.8] . Comment vérifier si une liste contient une valeur particulière ? Nous utilisons les opérateurs in ou not in : . numbers = [34, 67, 12, 29] my_number = 67 if number in numbers: print(&quot;%d is in the list!&quot; % number) my_number = 90 if number not in numbers: print(&quot;%d is not in the list!&quot; % number) . Les fonctions des listes . Il existe des fonctions built-in que nous pouvons utiliser sur les listes et autres séquences : . len(animals) # the sum of a list of numbers sum(numbers) # are any of these values true? any([1,0,1,0,1]) # are all of these values true? all([1,0,1,0,1]) . L&#39;objet list possède lui aussi de nombreuses fonctions utiles : . numbers = [1, 2, 3, 4, 5] # we already saw how to add an element to the end numbers.append(5) # count how many times a value appears in the list numbers.count(5) # append several values at once to the end numbers.extend([56, 2, 12]) # find the index of a value numbers.index(3) # if the value appears more than once, we will get the index of the first one numbers.index(2) # if the value is not in the list, we will get a ValueError! numbers.index(42) # insert a value at a particular index numbers.insert(0, 45) # insert 45 at the beginning of the list # remove an element by its index and assign it to a variable my_number = numbers.pop(0) # remove an element by its value numbers.remove(12) # if the value appears more than once, only the first one will be removed numbers.remove(5) . Nous pouvons aussi trier les listes de plusieurs façons : . numbers = [3, 2, 4, 1] # these return a modified copy, which we can print print(sorted(numbers)) print(list(reversed(numbers))) # the original list is unmodified print(numbers) # now we can modify it in place numbers.sort() numbers.reverse() print(numbers) . Les op&#233;rateurs arithm&#233;tiques . Nous pouvons combiner des listes et les étendre grace aux opérateurs arithmétiques + et * : . print([1, 2, 3] + [4, 5, 6]) # we can concatenate a list with itself by multiplying it by an integer print([1, 2, 3] * 3) # not all arithmetic operators can be used on lists -- this will give us an error! print([1, 2, 3] - [2, 3]) . Exercice 1 : . 1) Créez une liste a qui contient les trois premiers entiers positifs impairs et une liste b qui contient les trois premiers entiers positifs pairs. | 2) Créez une nouvelle liste c qui combine les nombres des deux listes (l&#39;ordre n&#39;a pas d&#39;importance). | 3) Créez une nouvelle liste d qui est une copie triée de c, en laissant c inchangé. | 4) Inversez d. | 5) Définissez le 4ème élément de c comme étant 42. | 5) Ajoutez 10 à la fin de d. | 6) Ajoutez 7, 8 et 9 à la fin du c. | 7) Affichez les trois premiers éléments de c. | 8) Affichez le dernier élément de d sans utiliser sa longueur. | 9) Affichez la longueur de d. | . 2. Les tuples (tuple) . Python a un autre type de séquence appelé tuple. Les tuples sont similaires aux listes, mais ils sont immuables. Les tuples sont définis avec un ensemble de valeurs séparées par des virgules entre parenthèses (( et )) : . WEEKDAYS = (&#39;Monday&#39;, &#39;Tuesday&#39;, &#39;Wednesday&#39;, &#39;Thursday&#39;, &#39;Friday&#39;, &#39;Saturday&#39;, &#39;Sunday&#39;) . Nous pouvons utiliser des tuples de la même manière que nous utilisons des listes, sauf que nous ne pouvons pas les modifier : . animals = (&#39;cat&#39;, &#39;dog&#39;, &#39;fish&#39;) # an empty tuple my_tuple = () # we can access a single element print(animals[0]) # we can get a slice print(animals[1:]) # note that our slice will be a new tuple, not a list # we can count values or look up an index animals.count(&#39;cat&#39;) animals.index(&#39;cat&#39;) # ... but this is not allowed: animals.append(&#39;canary&#39;) animal[1] = &#39;gerbil&#39; . A quoi servent les tuples ? Nous pouvons les utiliser pour créer une séquence de valeurs que nous ne voulons pas modifier. . Exercice 2 . 1) Créez un tuple a qui contient les quatre premiers entiers positifs et un tuple b qui contient les quatre entiers positifs suivants. | 2) Créez un tuple c qui combine tous les nombres de a et b dans n&#39;importe quel ordre. | 3) Créez un tuple d qui est une copie triée de c. | 4) Affichez le troisième élément de d. | 5) Affichez les trois derniers éléments de d sans utiliser sa longueur. | 6) Affichez la longueur de d. | . 3. Les sets (set) . Il existe encore un autre type de séquence appelé set. Un set est une collection d&#39;éléments uniques. Si nous ajoutons plusieurs copies du même élément à un set, les doublons seront éliminés et il nous restera un de chaque élément. Les sets sont définis avec un ensemble de valeurs séparées par des virgules entre accolades ({ et }) : . animals = {&#39;cat&#39;, &#39;dog&#39;, &#39;goldfish&#39;, &#39;canary&#39;, &#39;cat&#39;} print(animals) # the set will only contain one cat . Nous pouvons faire plusieurs opérations sur les sets : . even_numbers = {2, 4, 6, 8, 10} big_numbers = {6, 7, 8, 9, 10} # subtraction: big numbers which are not even print(big_numbers - even_numbers) # union: numbers which are big or even print(big_numbers | even_numbers) # intersection: numbers which are big and even print(big_numbers &amp; even_numbers) # numbers which are big or even but not both print(big_numbers ^ even_numbers) . Il est important de noter que contrairement aux listes et aux tuples, les sets ne sont pas ordonnés. Lorsque nous affichons un ensemble, l&#39;ordre des éléments sera aléatoire. Nous pouvons toujours l&#39;ordoner si besoin (cependant la fonction sorted nous renverra une liste): . print(animals) print(sorted(animals)) . Comment fait-on pour déclarer un set vide ? Nous devons utiliser la fonction set. Les dictionnaires, dont nous parlerons dans la section suivante, utilisaient des accolades avant que les ensembles ne les adoptent, donc un ensemble vide d&#39;accolades est en fait un dictionnaire vide : . a = {} # this is how we make an empty set b = set() . Exercice 3 : . 1) Créez un ensemble a qui contient les quatre premiers entiers positifs et un ensemble b qui contient les quatre premiers entiers positifs impairs. | 2) Créez un ensemble c qui combine tous les nombres qui sont dans a ou b (ou les deux). | 3) Créez un ensemble d qui contient tous les nombres de a mais pas de b. | 4) Créez un ensemble e qui contient tous les nombres de b mais pas de a. | 5) Créez un ensemble f qui contient tous les nombres qui sont à la fois dans a et dans b. | 6) Créez un ensemble g qui contient tous les nombres qui sont soit dans a soit dans b mais pas dans les deux. | 7) Affichez le nombre d&#39;éléments dans c. | . 4. Les range . Nous pouvons générer une séquence d&#39;entier (appelé range) grace à la fonction built-in : range. Les range sont des générateurs, nous verrons ces derniers en détail dans la prochaine partie. Pour l&#39;instant, nous avons juste besoin de savoir que les nombres de la plage sont générés un à un, et pas tous à la fois. . Dans les exemples ci-dessous, nous convertissons chaque range en list afin que tous les nombres soient générés et que nous puissions les afficher . print(list(range(10))) # print the integers from 1 to 10 print(list(range(1, 11))) # print the odd integers from 1 to 10 print(list(range(1, 11, 2))) . Comme vous pouvez le voir, si nous passons un seul paramètre à la fonction range, il est utilisé comme borne supérieure. Si nous utilisons deux paramètres, le premier est la borne inférieure et le second est la borne supérieure. Si nous en utilisons trois, le troisième paramètre est la taille du pas. La limite inférieure par défaut est zéro et la taille de pas par défaut est un. Notez que la plage inclut la limite inférieure et exclut la limite supérieure. . Exercice 4 : . 1) Créez un range a qui commence à partir de 0 et s&#39;étend sur 20 nombres. | 2) Créez un range b qui commence à partir de 3 et se termine à 12. | 3) Créez un range c qui contient un entier sur trois commençant à 2 et se terminant à 50. | . 5. Les dictionnaires dict . Le type de dictionnaire Python est appelé dict. Nous pouvons utiliser un dictionnaire pour stocker des paires clé-valeur. Les dict sont définis avec un ensemble de paires clé-valeur séparées par des virgules entre des accolades ({ et }). Nous utilisons deux points pour séparer chaque clé de sa valeur. Nous accédons aux valeurs du dictionnaire de la même manière que les éléments de liste ou de tuple, mais nous utilisons des clés au lieu d&#39;indices : . marbles = {&quot;red&quot;: 34, &quot;green&quot;: 30, &quot;brown&quot;: 31, &quot;yellow&quot;: 29 } personal_details = { &quot;name&quot;: &quot;Jane Doe&quot;, &quot;age&quot;: 38, # trailing comma is legal } print(marbles[&quot;green&quot;]) print(personal_details[&quot;name&quot;]) # This will give us an error, because there is no such key in the dictionary print(marbles[&quot;blue&quot;]) # modify a value marbles[&quot;red&quot;] += 3 personal_details[&quot;name&quot;] = &quot;Jane Q. Doe&quot; . Les clés d&#39;un dictionnaire n&#39;ont pas besoin d&#39;être des string, elles peuvent être de n&#39;importe quel type immuable, y compris des nombres et même des tuples. Nous pouvons mélanger différents types de clés et différents types de valeurs dans un dictionnaire. Les clés sont uniques, si nous répétons une clé, nous écraserons l&#39;ancienne valeur avec la nouvelle. Lorsque nous stockons une valeur dans un dictionnaire, la clé n&#39;a pas besoin d&#39;exister - elle sera créée automatiquement : . battleship_guesses = { (3, 4): False, (2, 6): True, (2, 5): True, } surnames = {} # this is an empty dictionary surnames[&quot;John&quot;] = &quot;Smith&quot; surnames[&quot;John&quot;] = &quot;Doe&quot; print(surnames) # we overwrote the older surname marbles = {&quot;red&quot;: 34, &quot;green&quot;: 30, &quot;brown&quot;: 31, &quot;yellow&quot;: 29 } marbles[&quot;blue&quot;] = 30 # this will work marbles[&quot;purple&quot;] += 2 # this will fail -- the increment operator needs an existing value to modify! . Voici quelques fonctions couramment utilisées pour les objets dict : . marbles = {&quot;red&quot;: 34, &quot;green&quot;: 30, &quot;brown&quot;: 31, &quot;yellow&quot;: 29 } # Get a value by its key, or None if it doesn&#39;t exist marbles.get(&quot;orange&quot;) # We can specify a different default marbles.get(&quot;orange&quot;, 0) # Add several items to the dictionary at once marbles.update({&quot;orange&quot;: 34, &quot;blue&quot;: 23, &quot;purple&quot;: 36}) # All the keys in the dictionary marbles.keys() # All the values in the dictionary marbles.values() # All the items in the dictionary marbles.items() . On peut vérifier si une clé est dans le dictionnaire en utilisant in et not in : . print(&quot;purple&quot; in marbles.keys()) print(&quot;white&quot; not in marbles) print(31 in marbles.values()) . Exercice 5 : . 1) Créez un dict qui stocke les numéros de téléphone (sous forme de valeurs de chaîne) et remplissez-le avec ces paires clé-valeur : | . Name Telephone number . Jane Doe | +27 555 5367 | . John Smith | +27 555 6254 | . Bob Stone | +27 555 5689 | . 2) Changez le numéro de Jane en +27 555 1024 | 3) Ajouter une nouvelle entrée pour une personne appelée Anna Cooper avec le numéro de téléphone +27 555 3237 | 4) Affichez le numéro de Bob. | 5) Affichez le numéro de Bob de manière à ce que Aucun ne soit imprimé si le nom de Bob n&#39;était pas dans le dictionnaire. | 6) Affichez toutes les clés. Le format n&#39;a pas d&#39;importance, tant qu&#39;ils sont tous visibles. | 7) Affichez toutes les valeurs. | . 6. Converstion des collections . Conversions implicites . Si nous essayons d&#39;itérer sur une collection dans une boucle for (quelque chose dont nous discuterons dans le prochain chapitre), Python essaiera de la convertir en quelque chose que nous pouvons parcourir s&#39;il sait comment le faire. Par exemple, les dict que nous avons vues ci-dessus ne sont pas réellement des itérateurs, mais Python sait comment les transformer en itérateurs, nous pouvons donc les utiliser dans une boucle for sans avoir à les convertir nous-mêmes. . Parfois, l&#39;itérateur que nous obtenons par défaut peut ne pas être ce à quoi nous nous attendions, si nous parcourons un dictionnaire dans une boucle for, nous parcourrons les clés. Si ce que nous voulons réellement faire est d&#39;itérer sur les valeurs, ou les paires clé et valeur, nous devrons le spécifier nous-mêmes en utilisant les fonctions values et items. . Conversions explicites . Nous pouvons convertir les différents types de séquences en utilisant les fonctions built-in (correspondant au type) pour convertir les séquences dans les types souhaités : . animals = [&#39;cat&#39;, &#39;dog&#39;, &#39;goldfish&#39;, &#39;canary&#39;, &#39;cat&#39;] animals_set = set(animals) animals_unique_list = list(animals_set) animals_unique_tuple = tuple(animals_unique_list) marbles = {&quot;red&quot;: 34, &quot;green&quot;: 30, &quot;brown&quot;: 31, &quot;yellow&quot;: 29 } colours = list(marbles) # the keys will be used by default counts = tuple(marbles.values()) # but we can use a view to get the values marbles_set = set(marbles.items()) # or the key-value pairs # Python doesn&#39;t know how to convert this into a dictionary dict([1, 2, 3, 4]) # but this will work dict([(1, 2), (3, 4)]) . 7. Les string sont des s&#233;quences . Les string sont également une sorte de type de séquence. Ce sont des séquences de caractères et partagent certaines propriétés avec d&#39;autres séquences. Par exemple, nous pouvons trouver la longueur d&#39;une string ou l&#39;index d&#39;un caractère dans la string, et nous pouvons accéder à des éléments individuels de la string ou des slice : . s = &quot;abracadabra&quot; print(len(s)) print(s.index(&quot;a&quot;)) print(s[0]) print(s[3:5]) print(&#39;a&#39; in &#39;abcd&#39;) # True print(&#39;ab&#39; in &#39;abcd&#39;) # also True . N&#39;oubliez pas que les chaînes sont immuables, la modification des caractères sur place n&#39;est pas autorisée : . s[0] = &quot;b&quot; . Les opérateurs in et not in ont un comportement spécial lorsqu&#39;il est appliqué aux string : nous pouvons l&#39;utiliser pour déterminer si une string contient un seul caractère en tant qu&#39;élément, mais nous pouvons également l&#39;utiliser pour vérifier si une string en contient une autre : . print(&#39;a&#39; in &#39;abcd&#39;) # True print(&#39;ab&#39; in &#39;abcd&#39;) # also True # this doesn&#39;t work for lists print([&#39;a&#39;, &#39;b&#39;] in [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]) # False . On peut convertir une string en list : . abc_list = list(&quot;abracadabra&quot;) . Et si on voulait convertir une liste de caractères en chaîne ? L&#39;utilisation de la fonction str sur la liste nous donnera simplement une chaîne affichable de la liste, y compris les virgules, les guillemets et les crochets. Pour fusionner des séquence de caractères (ou de string) en une seule string, nous devons utiliser la fonction join. . Cette fonction, attachée à une string fonction comme tel : . l = [&#39;a&#39;, &#39;b&#39;, &#39;r&#39;, &#39;a&#39;, &#39;c&#39;, &#39;a&#39;, &#39;d&#39;, &#39;a&#39;, &#39;b&#39;, &#39;r&#39;, &#39;a&#39;] s = &quot;&quot;.join(l) print(s) animals = (&#39;cat&#39;, &#39;dog&#39;, &#39;fish&#39;) # a space-separated list print(&quot; &quot;.join(animals)) # a comma-separated list print(&quot;,&quot;.join(animals)) # a comma-separated list with spaces print(&quot;, &quot;.join(animals)) . L&#39;opposé de la fonction join est la fonction split. Nous pouvons diviser une string en une liste de string en utilisant la fonction split. S&#39;il est appelé sans aucun paramètre, split divise une chaîne en mots, en utilisant n&#39;importe quel nombre de caractères blancs consécutifs comme délimiteur. Nous pouvons utiliser des paramètres supplémentaires pour spécifier un délimiteur différent ainsi qu&#39;une limite sur le nombre maximum de fractionnements à effectuer : . print(&quot;cat dog fish n&quot;.split()) print(&quot;cat|dog|fish&quot;.split(&quot;|&quot;)) print(&quot;cat, dog, fish&quot;.split(&quot;, &quot;)) print(&quot;cat, dog, fish&quot;.split(&quot;, &quot;, 1)) . Exercice 6 . 1) Convertissez une liste qui contient les nombres 1, 1, 2, 3 et 3, et convertissez-la en un tuple a. | 2) Convertir a en liste b. Affichez sa longueur. | 3) Convertir b en set c. Affichez sa longueur. | 4) Convertir c en liste d. Affichez sa longueur. | 5) Créez un range qui commence à 1 et se termine à 10. Convertissez-la en liste e. | 6) Créez le dictionnaire de l&#39;exercice précédent. Créez une liste t qui contient toutes les paires clé-valeur du dictionnaire sous forme de tuples. | 7) Créez une liste v de toutes les valeurs du dictionnaire. | 8) Créez une liste k de toutes les clés du dictionnaire. | 9) Créez une chaîne s contenant le mot « antidisestablishmentarianism ». Utilisez la fonction sorted dessus. Quel est le type de sortie ? Concaténez les lettres de la sortie dans une chaîne s2. | 10) Divisez la chaîne &quot;le renard brun rapide a sauté par-dessus le chien paresseux&quot; en une liste w de mots individuels. | . Les s&#233;quences &#224; 2 dimensions . La plupart des séquences que nous avons vues jusqu&#39;à présent étaient unidimensionnelles : chaque séquence est une ligne d&#39;éléments. Que se passe-t-il si nous voulons utiliser une séquence pour représenter une structure de données bidimensionnelle, qui comporte à la fois des lignes et des colonnes ? La façon la plus simple de le faire est de créer une séquence dans laquelle chaque élément est également une séquence. Par exemple, nous pouvons créer une liste de listes : . my_table = [ [1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12], ] . La liste extérieure a quatre éléments, et chacun de ces éléments est une liste avec trois éléments (qui sont des nombres). Pour accéder à l&#39;un de ces nombres, nous devons utiliser deux indices - un pour la liste externe et un pour la liste interne : . print(my_table[0][0]) # lists are mutable, so we can do this my_table[0][0] = 42 . orsque nous utilisons une séquence bidimensionnelle pour représenter des données tabulaires, chaque séquence interne aura la même longueur, car un tableau est rectangulaire, mais rien ne nous empêche de construire des séquences bidimensionnelles qui n&#39;ont pas cette propriété : . my_2d_list = [ [0], [1, 2, 3, 4], [5, 6], ] . On peut aussi faire une séquence tridimensionnelle en faisant une liste de listes de listes : . my_3d_list = [ [[1, 2], [3, 4]], [[5, 6], [7, 8]], ] print(my_3d_list[0][0][0]) . Exemple : emploi du temps . Si nous voulions faire une liste en deux dimensions pour représenter un emploi du temps hebdomadaire, nous pourrions soit avoir des jours comme liste extérieure et des créneaux horaires comme liste intérieure ou l&#39;inverse - nous devrons nous rappeler quelle plage nous avons choisie pour être la lignes et dont les colonnes. . Supposons que nous voulions initialiser l&#39;horaire avec une chaîne vide dans chaque plage horaire – disons que nous avons 24 plages horaires d&#39;une heure chaque jour. Cela fait sept listes de 24 éléments chacune : . day = [&quot;&quot;] * 24 print(day) . Mais que se passe-t-il si nous répétons un jour sept fois pour faire une semaine ? . timetable = [day] * 7 print(timetable) . Voyons ce qui se passe lorsque nous essayons de programmer une réunion pour le lundi après-midi : . timetable[0][15] = &quot;meeting with Jane&quot; print(timetable) . Chaque jour a la même réunion l&#39;après-midi ! Qu&#39;est ce qui s&#39;est passé ? Lorsque nous avons multiplié notre liste de jours par sept, nous avons rempli notre emploi du temps avec le même objet list, répété sept fois. Tous les éléments de notre emploi du temps sont le même jour, donc peu importe celui que nous modifions, nous les modifions tous en même temps. . Pourquoi cela n&#39;avait-il pas d&#39;importance lorsque nous avons fait la liste des jours en multipliant la même chaîne vide 24 fois ? Parce que les string sont immuables. Nous ne pouvons modifier les valeurs des string dans la liste des jours qu&#39;en leur attribuant de nouvelles valeurs, nous ne pouvons pas les modifier directement, donc peu importe qu&#39;elles commencent toutes par le même objet de chaîne. . Ce que nous voulons en fait, ce sont sept copies d&#39;une liste de jours dans notre emploi du temps : . timetable = [[&quot;&quot;] * 24 for day in range(7)] . Exercice 7 . 1) Créez une liste a qui contient trois tuples. Le premier tuple doit contenir un seul élément, le deuxième deux éléments et le troisième trois éléments. | 2) Afficher le deuxième élément du deuxième élément de a. | 3) Créez une liste b qui contient quatre listes, chacune contenant quatre éléments. | 4) Affichez les deux derniers éléments du premier élément de b. | .",
            "url": "https://axi-technologies.github.io/AXI-Fastpages/python-intro-gen/chapter/3/lesson/1/",
            "relUrl": "/python-intro-gen/chapter/3/lesson/1/",
            "date": " • Jan 2, 2022"
        }
        
    
  
    
        ,"post6": {
            "title": "Chapitre 2 : Les conditions",
            "content": "Dans ce chapitre, nous allons découvrir les instructions de sélection : if, qui permettent à un programme de choisir quand exécuter certaines instructions. . Les gens prennent des décisions au quotidien. Que dois-je avoir pour le déjeuner? Que dois-je faire ce week-end ? Chaque fois que vous prenez une décision, vous la basez sur un certain critère. Par exemple, vous pouvez décider quoi manger pour le déjeuner en fonction de votre humeur du moment ou si vous suivez un régime. Après avoir pris cette décision, vous agissez en conséquence. Ainsi, la prise de décision est un processus en deux étapes : . d&#39;abord décider quoi faire sur la base d&#39;un critère | faire une action. | . 1. Les conditions . L&#39;instruction : if . La prise de décision par ordinateur repose sur le même processus en deux étapes. En Python, les décisions sont prises avec l&#39;instruction if . if condition: if_body . age = 17 if age &lt; 18: print(&quot;Cannot vote&quot;) . De nombreuses instructions if comparent deux valeurs afin de prendre une décision. Dans le dernier exemple, nous avons comparé la variable age à l&#39;entier 18 pour tester si l&#39;âge est inférieur à 18. Nous avons utilisé l&#39;opérateur &lt; pour la comparaison. Cet opérateur est l&#39;un des opérateurs relationnels utilisables en Python. Le tableau ci-dessous montre les opérateurs relationnels de Python. . Operator Description Example . == | equal to | if (age == 18) | . != | not equal to | if (score != 10) | . &gt; | greater than | if (num_people &gt; 50) | . &lt; | less than | if (price &lt; 25) | . &gt;= | greater than or equal to | if (total &gt;= 50) | . &lt;= | less than or equal to | if (value &lt;= 30) | . Attention : l&#39;opérateur == ne doit pas être confondu avec le symbole = (qui lui, assigne des variables). . Le bloque de code (il peut y avoir plus d&#39;une intruction dans une condition if) qui va être executer lorsque le critère if est validé doit être indenté : . age = 23 count = 0 if age &lt; 18: # This is a block comment print(&quot;Cannot vote&quot;) count += 1 . Nous pouvons aussi imbriquer des conditions : . age = 23 count = 0 if age &lt; 18: # This is a block comment print(&quot;Cannot vote&quot;) count += 1 if age == 17: print(&quot;Next year !&quot;) . La clause : else . Une partie facultative d&#39;une instruction if est la clause else. Il nous permet de spécifier une instruction alternative (ou un ensemble d&#39;instructions) à exécuter si la condition n&#39;est pas remplie : . age = 23 count = 0 if age &lt; 18: print(&quot;Cannot vote&quot;) else: print(&quot;Can vote&quot;) . Exercice 1 : . 1) Pour chaque confidition, devinez si elle est valide ou non et expliquez pourquoi. - a) `if (x &gt; 4)` - b) `if x == 2` - c) `if (y =&lt; 4)` - d) `if (y = 5)` - e) `if (3 &lt;= a)` - f) `if (1 - 1)` - g) `if ((1 - 1) &lt;= 0)` - h) `if (name == &quot;James&quot;)` . | . 2) Qu&#39;est-ce qui va être affiché à l&#39;écran avec le code ci-dessous. Expliquez pourquoi : | . x = 2 if x &gt; 3: print(&quot;This number&quot;) print(&quot;is greater&quot;) print(&quot;than 3.&quot;) . 3) Comment peut-on simplifier les codes suivants ? | . a = 1 if bool(a) == True: print(&quot;a is true&quot;) . b = 0 if x &gt; 50: b += 1 a = 5 else: b -= 1 a = 5 . La clause : elif . L&#39;instruction else nous permet de spécifier des actions pour le cas où la condition est fausse. Cependant, il peut y avoir des cas dans lesquels nous aimerions gérer plus de deux alternatives. . Dans le code ci-dessous, nous voulons générer un grade à partir d&#39;une note (mark) : . mark = 36 if mark &gt;= 80: grade = &#39;A&#39; else: if mark &gt;= 65: grade = &#39;B&#39; else: if mark &gt;= 50: grade = &#39;C&#39; else: grade = &#39;D&#39; print(grade) . Ce code est un peu difficile à lire. Chaque fois que nous ajoutons un if imbriqué, nous devons augmenter l&#39;indentation, de sorte que toutes nos alternatives sont indentées différemment. Nous pouvons écrire ce code plus proprement en utilisant des clauses elif : . mark = 36 if mark &gt;= 80: grade = &#39;A&#39; elif mark &gt;= 65: grade = &#39;B&#39; elif mark &gt;= 50: grade = &#39;C&#39; else: grade = &#39;D&#39; print(mark) . 2. Le type bool&#233;en : bool . En Python, il existe un type de valeur pour les variables qui peut être vrai (True) ou faux (False) : le type booléen (bool). Python convertira implicitement tout autre type de valeur en booléen si nous l&#39;utilisons comme un booléen, par exemple comme condition dans une instruction if. Nous n&#39;aurons presque jamais besoin de convertir des valeurs en bool explicitement. . 3. Les op&#233;rateurs bool&#233;ens . Les décisions sont souvent basées sur plus d&#39;un facteur. Par exemple, vous pouvez décider d&#39;acheter une chemise uniquement si vous l&#39;aimez ET (and) qu&#39;elle coûte moins de 100€. Ou vous pouvez décider de commander à manger ce soir si vous n&#39;avez rien dans le frigo OU (or) si vous n&#39;avez pas envie de cuisiner. . Vous pouvez également modifier les conditions en les annulant. Par exemple, vous allez au concert demain s&#39;il ne pleut PAS (not). . Nous pouvons avoir aussi en python un groupement de condition liés entre eux par les opérateurs booléens. . and : a and b est vrai si a et b sont vrai. | or : a or b est vrai si a ou b est vrai. | not : not b est l&#39;inverse de b : faux si b est vrai, vrai si b est faux. | . Table des valeurs : . a operator b result . True | and | True | True | . True | and | False | False | . False | and | True | False | . False | and | False | False | . True | or | True | True | . True | or | False | True | . False | or | True | True | . False | or | False | False | . | not | False | True | . | not | True | False | . Bonne pratique : . x, y, z = 1, 2, 3 # Bad notation if x != 0: if y != 0: if z != 0: print(1/(x*y*z)) # Same behavior with good notation if x != 0 and y != 0 and z != 0: print(1/(x*y*z)) . 4. L&#39;ordre de lecture des expressions . L&#39;ordre d&#39;interprétations des opérateurs python est le suivant : . Operators . () | . ** | . *, /, % | . +, - | . &lt;, &lt;=, &gt;, &gt;= ==, != | . is, is not | . not | . and | . or | . 5. Inverser des expressions . L&#39;opérateur not peut rendre les expressions plus difficiles à comprendre, surtout s&#39;il est utilisé plusieurs fois. Essayez d&#39;utiliser l&#39;opérateur not uniquement là où il est logique de l&#39;avoir. La plupart des gens trouvent qu&#39;il est plus facile de lire des déclarations positives que négatives. Parfois, nous pouvons utiliser l&#39;opérateur relationnel opposé pour éviter d&#39;utiliser l&#39;opérateur not, par exemple : . if not mark &lt; 50: print(&quot;You passed&quot;) # is the same as if mark &gt;= 50: print(&quot;You passed&quot;) . Ce tableau présente chaque opérateur relationnel et son contraire : . Operator Opposite . == | != | . &gt; | &lt;= | . &lt; | &gt;= | . Nous pouvons aussi inverser les opérateur and et or de la manière suivante : . not (a and b) = (not a) or (not b) not (a or b) = (not a) and (not b) . if not (age &gt; 0 and age &lt;= 120): print(&quot;Invalid age&quot;) # is the same as if age &lt;= 0 or age &gt; 120: print(&quot;Invalid age&quot;) . Exercice 2 : . 1) Pour quelles valeurs input ce programme affichera-t-il True ? | . if not input &gt; 5: print(&quot;True&quot;) . 2) Pour quelles valeurs absentee_rate et global_mark ce programme affichera-t-il Vous avez réussi le cours. ? | . if absentee_rate &lt;= 5 and overall_mark &gt;= 50: print(&quot;You have passed the course.&quot;) . 3) Pour quelles valeurs x ce programme affichera-t-il True ? | . if x &gt; 1 or x &lt;= 8: print(&quot;True&quot;) . 4) Éliminez l&#39;instruction not de chacune de ces expressions booléennes : | . not total &lt;= 2 not count &gt; 40 not (value &gt; 20.0 and total != 100.0) not (angle &gt; 180 and width == 5) not (count == 5 and not (value != 10) or count &gt; 50) not (value &gt; 200 or value &lt; 0 and not total == 0) . 6. L&#39;op&#233;rateur conditionnel . Python a une autre façon d&#39;écrire une sélection dans un programme grâce à l&#39;opérateur conditionnel : . if (score &gt;= 50): result = &quot;Pass&quot; else: result = &quot;Fail&quot; # Is the same as result = &quot;Pass&quot; if (score &gt;= 50) else &quot;Fail&quot; . Exercice 3 : . 1) Ré-écrivez le code suivant en utilisant la clause : elif | . if temperature &lt; 0: print(&quot;Below freezing&quot;) else: if temperature &lt; 10: print(&quot;Very cold&quot;) else: if temperature &lt; 20: print(&quot;Chilly&quot;) else: if temperature &lt; 30: print(&quot;Warm&quot;) else: if temperature &lt; 40: print(&quot;Hot&quot;) else: print(&quot;Too hot&quot;) . 2) Écrire un programme Python pour attribuer des notes aux étudiants à la fin de l&#39;année. Le programme doit effectuer les opérations suivantes : a) Demandez un numéro d&#39;étudiant. | b) Demander la note de stage de l&#39;élève. | c) Demandez la note du test de l&#39;élève. | d) Calculez si la moyenne de l&#39;étudiant jusqu&#39;à présent est suffisamment élevée pour qu&#39;il soit autorisé à passer l&#39;examen. Si la moyenne des notes (stage et test) est inférieure à 40, l&#39;étudiant devrait automatiquement obtenir une note F, et le programme devrait afficher la note et quitter sans effectuer les étapes suivantes. | e) Demandez la note de l&#39;examen de l&#39;étudiant. | f) Calculer la note finale de l&#39;élève. Les notes de stage et du test comptent pour 25 % de la note finale chacune, et l&#39;examen final devrait compter pour les 50 % restants. | g) Calculez et affichez la note de l&#39;élève, selon le tableau suivant : | . | . Weighted final score Final grade . 80 &lt;= mark &lt;= 100 | A | . 70 &lt;= mark &lt; 80 | B | . 60 &lt;= mark &lt; 70 | C | . 50 &lt;= mark &lt; 60 | D | . mark &lt; 50 | E | .",
            "url": "https://axi-technologies.github.io/AXI-Fastpages/python-intro-gen/chapter/2/lesson/2/",
            "relUrl": "/python-intro-gen/chapter/2/lesson/2/",
            "date": " • Jan 2, 2022"
        }
        
    
  
    
        ,"post7": {
            "title": "Chapitre 2 : Les variables Python",
            "content": "1. Cr&#233;ation . Une variable est une étiquette pour un emplacement en mémoire. Il peut être utilisé pour contenir une valeur. Dans les langages à typage statique, les variables ont des types prédéterminés et une variable ne peut être utilisée que pour contenir des valeurs de ce type. En Python, nous pouvons réutiliser la même variable pour stocker des valeurs de tout type. . Cr&#233;ation d&#39;une variable . Création de la variable countdont la valeur est 0 : . count = 0 . La port&#233;e (scope) des variables . Toutes les variables ne sont pas accessibles depuis toutes les parties de notre programme, et toutes les variables n&#39;existent pas pour la même durée. L&#39;endroit où une variable est accessible et sa durée d&#39;existence dépendent de la façon dont elle est définie. Nous appelons la partie d&#39;un programme où une variable est accessible sa portée (scope), et la durée pendant laquelle la variable existe : . a = 0 if a == 0: # This is still a global variable b = 1 def my_function(c): # this is a local variable d = 3 print(c) print(d) # Now we call the function, passing the value 7 as the first and only parameter my_function(7) # a and b still exist print(a) print(b) # c and d don&#39;t exist anymore -- these statements will give us name errors! print(c) print(d) . L&#39;op&#233;rateur = . Cet opérateur affecte la valeur du côté droit à la variable du côté gauche, créant parfois la variable en premier. Si le côté droit est une expression (telle qu&#39;une expression arithmétique), elle sera évaluée avant que l&#39;affectation ne se produise. Voici quelques exemples: . total = 3 a_number = 5 # a_number becomes 5 a_number = total # a_number becomes the value of total a_number = total + 5 # a_number becomes the value of total + 5 a_number = a_number + 1 # a_number becomes the value of a_number + 1 # these are all illegal: 3 = 4 3 = a a + b = 3 # both a and b will be set to zero: a = b = 0 # this is illegal, because we can&#39;t set 0 to b: a = 0 = b . Les op&#233;rateurs compos&#233;s . Operator Example Equivalent to . += | a += 5 | a = a + 5 | . -= | a -= 5 | a = a - 5 | . *= | a *= 5 | a = a * 5 | . /= | a /= 5 | a = a / 5 | . %= | a %= 5 | a = a % 5 | . Exercice 1 : . 1) Décrivez le scope des variables a, b, c et d dans cet exemple : | . def my_function(a): b = a - 2 return b c = 3 if c &gt; 2: d = my_function(5) print(d) . 2) Quelle est la durée de vie de ces variables ? Quand seront-elles créés et détruits ? | 3) Pouvez-vous deviner ce qui se passerait si nous attribuions à c une valeur de 1 à la place ? | . 2. Modification . Dans certaines langues, il est possible de définir des variables spéciales auxquelles une valeur ne peut être affectée qu&#39;une seule fois – une fois leurs valeurs définies, elles ne peuvent pas être modifiées. Nous appelons ces types de variables des constantes. Python ne nous permet pas de définir une telle restriction sur les variables, mais il existe une convention largement utilisée pour marquer certaines variables pour indiquer que leurs valeurs ne sont pas censées changer : nous écrivons leurs noms en majuscules, avec des traits de soulignement séparant les mots : . NUMBER_OF_DAYS_IN_A_WEEK = 7 NUMBER_OF_MONTHS_IN_A_YEAR = 12 # Nothing is actually stopping us from redefining them... NUMBER_OF_DAYS_IN_A_WEEK = 8 # ...but it&#39;s probably not a good idea. . Les types : mutable et immuable . Certaines valeurs en python peuvent être modifiées, d&#39;autres non. Cela ne signifie jamais que nous ne pouvons pas changer la valeur d&#39;une variable - mais si une variable contient une valeur d&#39;un type immuable, nous ne pouvons lui attribuer qu&#39;une nouvelle valeur. Nous ne pouvons en aucun cas modifier la valeur existante. . Les entiers, les nombres à virgule flottante et les chaînes sont tous des types immuables - dans tous les exemples précédents, lorsque nous avons modifié les valeurs des variables existantes, nous avons utilisé l&#39;opérateur d&#39;affectation pour leur attribuer de nouvelles valeurs : . a = 3 a = 2 b = &quot;jane&quot; b = &quot;bob&quot; # This operator doesn’t modify the value of total, it assign a new value total += 4 . Les objets de type mutable peuvent être modifier de différentes manières suivant leur type. . my_list = [1, 2, 3] my_list[0] = 5 # we can change just the first element of the list print(my_list) # A class is a mutable object type class MyClass(object): pass # Now we make a very simple object using our class as a type my_object = MyClass() # We can change the values of attributes on the object my_object.some_property = 42 . 3. Les conversions . Au fur et à mesure que nous écrivons des programmes, nous constaterons souvent que nous devons convertir des données d&#39;un type à un autre, par exemple d&#39;une chaîne à un entier ou d&#39;un entier à un nombre à virgule flottante. Il existe deux types de conversions de type en Python : les conversions implicites et explicites. . Les conservions implicites . Rappelez-vous de la section sur les opérateurs à virgule flottante que nous pouvons combiner arbitrairement des entiers et des nombres à virgule flottante dans une expression arithmétique - et que le résultat d&#39;une telle expression sera toujours un nombre à virgule flottante. En effet, Python convertira les entiers en nombres à virgule flottante avant d&#39;évaluer l&#39;expression. Il s&#39;agit d&#39;une conversion implicite - nous n&#39;avons rien à convertir nous-mêmes. Il n&#39;y a généralement pas de perte de précision lorsqu&#39;un entier est converti en un nombre à virgule flottante. . a = 8.5 * 2 print(a) b = 3 / 2 print(b) c = 8.5 + 7 // 3 - 2.5 print(c) . Les conservions explicites (cast) . La conversion de nombres de float en int entraînera une perte de précision. Par exemple, essayez de convertir 5.834 en int : il n&#39;est pas possible de le faire sans perdre en précision. Pour que cela se produise, nous devons explicitement dire à Python que nous sommes conscients que la précision sera perdue. . Par exemple, nous devons dire au compilateur de convertir un float en un int comme ceci : . i = int(5.834) print(i) . La fonction int convertit un float en un int en supprimant la partie décimale : elle sera toujours arrondie à l&#39;inférieur. Si nous voulons plus de contrôle sur la façon dont le nombre est arrondi, nous devrons utiliser une fonction différente : . import math # ceil returns the closest integer greater than or equal to the number # (so it always rounds up) i = math.ceil(5.834) print(i) # floor returns the closest integer less than or equal to the number # (so it always rounds down) i = math.floor(5.834) print(i) # round returns the closest integer to the number # (so it rounds up or down) # Note that this is a built-in function -- we don&#39;t need to import math to use it. i = round(5.834) print(i) i = round(5.334) print(i) . 4. Le typage . Les langages de programmation possède différentes manières de typer des variables. On va notamment distinguer 2 caractéristiques : . Typage statique ou dynamique . langage à typage statique : Un langage dans lequel les types sont fixés à la compilation. La plupart des langages à typage statique obtiennent cela en exigeant la déclaration de toutes les variables et de leur type avant leur utilisation. Java et C sont des langages à typage statique. | langage à typage dynamique : Un langage dans lequel les types sont découverts à l&#39;exécution, l&#39;inverse du typage statique. VBScript et Python sont des langages à typage dynamique, ils déterminent le type d&#39;une variable la première fois que vous lui assignez une valeur. | . Les langages fortement typ&#233; ou faiblement typ&#233; . langage fortement typé : Un langage dans lequel les types sont toujours appliqués. Java et Python sont fortement typés. Un entier ne peut être traité comme une chaîne sans conversion explicite | langage faiblement typé : Un langage dans lequel les types peuvent être ignorés, l&#39;inverse de fortement typé. VBScript est faiblement typé. En VBScript, vous pouvez concaténer la chaîne &#39;12&#39; et l&#39;entier 3 pour obtenir la chaîne &#39;123&#39; et traiter le résultat comme l&#39;entier 123, le tout sans faire de conversion explicite. | . Python est donc à la fois à typage dynamique (il n&#39;utilise pas de déclaration de type explicite) et fortement typé (une fois qu&#39;une variable a un type, cela a une importance. . On peut connaitre le type d&#39;une variable python avec la fonction built-in : type : . print(type(&#39;Hello World !&#39;)) . print(type(123)) . print(type(0.23)) .",
            "url": "https://axi-technologies.github.io/AXI-Fastpages/python-intro-gen/chapter/2/lesson/1/",
            "relUrl": "/python-intro-gen/chapter/2/lesson/1/",
            "date": " • Jan 2, 2022"
        }
        
    
  
    
        ,"post8": {
            "title": "Introduction 2 : Syntaxe",
            "content": "1. Les mot cl&#233;s . L&#39;interprétation d&#39;un programme Python passe par l&#39;utilisation de mots clé. Les mots clés ont été conservés à des fins spécifiques et ne peuvent être utilisés à d&#39;autres fins dans le programme. En voici certains : . False class finally is return None continue for lambda try True def from nonlocal while and del global not with as elif if or yield assert else import pass break except in raise . 2. Les variables . Lorsque nous écrivons un programme Python, nous allons créer des variables qui stockent des valeurs telles que des nombres ou des chaînes de caractères, ainsi que des fonctions et des classes. Ces variables doivent avoir un nom unique qui respecte les règles suivantes : . Il ne peut contenir que des lettres (majuscules ou minuscules), des chiffres ou le caractère de soulignement (_) (pas d&#39;espaces !). | Il ne peut pas commencer par un chiffre. | Ce n&#39;est pas un mot-clé. | . Il est fortement recommandé de suivre les bonnes pratiques de nommage des variables pour garder une bonne compréhension du code : . Syntax error Bad practice Good practice . Person Record | PRcrd | PersonRecord | . DEFAULT-HEIGHT | Default_Ht | DEFAULT_HEIGHT | . class | Class | AlgebraCourse | . 2totalweight | num2 | total_weight | . Exercice 1 : . Expliquez pourquoi les noms de variables dans la colonne Syntax error ne sont pas valident. | . 3. L&#39;indentation . De nombreux langages organisent le code en blocs à l&#39;aide d&#39;accolades ({ et }) ou d&#39;instructions BEGIN et END, ces langages nous encouragent à indenter les blocs pour faciliter la lecture du code, mais l&#39;indentation n&#39;est pas obligatoire. Python utilise l&#39;indentation uniquement pour délimiter les blocs, nous devons donc indenter notre code : . # Examples : # Functions def my_fuction(): print(&quot;Hello World in &#39;function&#39;&quot;) # function execution is outside function block my_fuction() # If statements if &quot;Hello&quot; != &quot;World&quot;: print(&quot;Hello World in &#39;if&#39;&quot;) # Loops for i in [0, 1, 2]: print(f&quot;Hello World in &#39;loop {i}&#39;&quot;) . Exercice 2 : . Ré-écrivez le code suivant avec la bonne indentation : . def happy_day(day): if day == &quot;monday&quot;: return &quot;:(&quot; if day != &quot;monday&quot;: return &quot;:D&quot; print(happy_day(&quot;sunday&quot;)) print(happy_day(&quot;monday&quot;)) . 4. La sensibilit&#233; &#224; la casse . Python est senbible à la casse, ce qui signifie que l&#39;expression def main() n&#39;est pas la même que DEF MAIN() . var_a = &quot;lowercase&quot; var_A = &quot;UPPERCASE&quot; print(var_a) print(var_A) . 5. Les commentaires . # print(&#39;hello&#39;) # the code above is not executed # But the code below will be print(&#39;World&#39;) . 6. Ecrire des informations (print) . Le moyen le plus simple de générer des informations consiste à afficher une chaîne de caractères (string) à l&#39;aide de la fonction `print. La chaîne de caractères est contenu dans des guillemets. Nous pouvons utiliser des guillemets simples (&#39;) ou des guillemets doubles (&quot;). Le guillemet de début et le guillemet de fin doivent correspondre. . print(&#39;Hello&#39;) print(&quot;Hello world !&quot;) . 7. Saisir des informations (input) . La saisie d&#39;information de l&#39;utilisateur se fait avec la fonction input : . first_number = input(&#39;Enter the first number: &#39;) . 8. Les types . Il existe de nombreux types d&#39;informations qu&#39;un ordinateur peut traiter, comme les chiffres et les caractères. En Python (et d&#39;autres langages de programmation), les types d&#39;informations que le langage est capable de gérer sont appelés types. De nombreux types courants sont intégrés à Python, par exemple des entiers, des nombres à virgule flottante et des chaînes de caractères. Les utilisateurs peuvent également définir leurs propres types à l&#39;aide de classes. . Dans de nombreux langages, une distinction est faite entre les types intégrés (qui sont souvent appelés « types primitifs » pour cette raison) et les classes, mais en Python, ils sont indiscernables. Tout en Python est un objet (c&#39;est-à-dire une instance d&#39;une classe) - qui inclut même des listes et des fonctions. . 9. Les entiers (int) . Un entier (de type int) est un nombre entier tel que 1, 5, 1350 ou -34. Les nombres avec des points décimaux sont des nombres à virgule flottante (float). 2.3, 12.34, 1.0 ne sont pas des entiers mais des float. . print(3) # We can also do operations on integers print(1 + 2) . Les op&#233;rations . Nous pouvons effectuer des opérations suivantes sur les entiers : . Operation Symbol Example Result . Addition | + | 28 + 10 | 38 | . Subtraction | - | 28 - 10 | 18 | . Multiplication | * | 28 * 10 | 280 | . Division | // | 28 // 10 | 2 | . Modulus (remainder) | % | 28 % 10 | 8 | . Exponent (power) | ** | 28**10 | 296196766695424 | . Priorit&#233; de l&#39;op&#233;rateur . Une autre chose importante à garder à l&#39;esprit est la priorité des opérateurs. Par exemple, 1 + 2 // 3 signifie-t-il (1 + 2) // 3 ou 1 + (2 // 3) ? Python dispose d&#39;un moyen spécifique et prévisible pour déterminer l&#39;ordre dans lequel il effectue les opérations. Pour les opérations sur des nombres entiers, le système traitera les opérateurs dans l&#39;ordre suivant : (), **, *, //, %, et enfin + et -. . Expression How Python evaluates Result . 20 + 10 // 2 | 20 + (10 // 2) | 25 | . 20 + 10 - 2 | (20 + 10) - 2 | 28 | . 20 - 10 + 2 | (20 - 10) + 2 | 12 | . 20 - 10 * 2 | 20 - (10 * 2) | 0 | . 20 // 10 * 2 | (20 // 10) * 2 | 4 | . 20 * 10 // 2 | (20 * 10) // 2 | 100 | . 20 * 10 ** 2 | 20 * (10 ** 2) | 2000 | . 2 * 3 / 4 # is evaluated left to right: (2 * 3) / 4 # ** is right-associative, so 2 ** 3 ** 4 # is evaluated right to left: 2 ** (3 ** 4) . Exercice 3 : . 1) Lesquels des nombres suivants sont des entiers Python valides ? 110, 1.0, 17.5, -39, -2.3 | 2) Que se passe-t-il lorsque vous executez 1 // 0 dans la console Python ? Pourquoi cela arrive-t-il ? | 3) Quels sont les résultats des opérations suivantes et expliquez pourquoi : | . a = 15 + 20 * 3 b = 13 // 2 + 3 c = 31 + 10 // 3 d = 20 % 7 // 3 e = 2 ** 3 ** 2 . 10. Les nombres &#224; virgules flottante (float) . Les nombres à virgule flottante (de type float) sont des nombres avec une virgule décimale ou un exposant (ou les deux). Les exemples sont 5.0, 10.24, 0.0, 12. et 0.3. Nous pouvons utiliser la notation scientifique pour désigner des nombres à virgule flottante très grands ou très petits, par exemple 3,8 x 10^15 s&#39;écrira 3.8e15 ou 3.8e+15. . La fonction print affichera une notation optimisée des objets de type float : . print(3213.) print(.3213) print(0.3000) print(1e10) print(1e100) print(0.0000000001) . La division . Les opérateurs arithmétiques pour les float sont les mêmes que pour les entiers. A l&#39;exception de la division - l&#39;opérateur de division à virgule flottante est /. Les opérations en float produisent toujours une solution en virgule flottante. L&#39;ordre de priorité de ces opérateurs est le même que celui des opérateurs entiers. . Exercice 4 : . 1) Parmi les éléments suivants, lesquels sont des nombres à virgule flottante Python ? 1, 1.0, 1.12e4, -3.141759, 735, 0.57721566, 7.5e-3 | 2) Quelle est la différence entre une division entière et une division à virgule flottante ? Quel est l&#39;opérateur utilisé pour la division entière ? Quel est l&#39;opérateur utilisé pour la division en virgule flottante ? | 3) Quels sont les résultats des opérations suivantes ? Expliquer pourquoi: | . a = 1.5 + 2 b = 1.5 // 2.0 c = 1.5 / 2.0 d = 1.5 ** 2 e = 1 / 2 f = -3 // 2 . 5) Que se passe-t-il lorsque vous évaluez 1/0 dans la console Python ? | 6) Que se passe-t-il lorsque vous évaluez 1e1000 ? Et -1e1000 ? Et type(1e1000) ? | . 11. Les cha&#238;nes de caract&#232;res (str) . Les objet de type str (appelé string) sont des chaînes de caractères. À bien des égards, les chaînes se comportent de manière similaire aux listes (type list), dont nous parlerons dans un chapitre ultérieur, mais elles ont également certaines fonctionnalités spécifiques au texte. . my_string_1 = &quot;Hello World !&quot; print(my_string_1) # This is the same string my_string_2 = &#39;Hello World !&#39; . Formatage . Nous aurons souvent besoin d&#39;afficher un message qui n&#39;est pas une string fixe, peut-être que nous voulons inclure des nombres ou d&#39;autres valeurs qui sont stockées dans des variables. La méthode recommandée pour inclure ces variables dans notre message est d&#39;utiliser les fstring. Il s&#39;agit d&#39;une chaine de caractère (précédé de la lettre f) qui va inteprété des variables ou du code à l&#39;intérieur de balises : les crochets {}). Exemple : . name = &#39;John&#39; age = &#39;72&#39; print(f&#39;Hello! My name is {name}&#39;) print(f&quot;Hello! My name is {name}, and I am {age} years old.&quot;) . Les s&#233;quences d&#39;&#233;chappement ( n) . Une séquence d&#39;échappement (de caractères) peut être utilisée pour désigner un caractère spécial qui ne peut pas être tapé facilement sur un clavier ou qui a été réservé à d&#39;autres fins. Par exemple, nous pouvons vouloir insérer une nouvelle ligne dans notre chaîne : . print(&#39;This is one line. nThis is another line.&#39;) . Si notre chaîne est entourée de guillemets simples, nous devrons échapper aux apostrophes et nous devons faire de même pour les guillemets doubles dans une chaîne entourée de guillemets doubles. Une séquence d&#39;échappement commence par une barre oblique inverse ( ) : . print(&#39;He said : &quot;Hi! I &#39;m John&quot;.&#39;) print(&quot;He said : &quot;Hi! I&#39;m John &quot;.&quot;) . Les séquences d&#39;échappement de base : . Sequence Meaning . | literal backslash | . &#39; | single quote | . &quot; | double quote | . n | newline | . t | tab | . Les op&#233;rations . Nous pouvons modifier, fusionner et diviser des string de bien des manière. . Tout d&#39;abord, nous pouvons concaténer des string avec l&#39;opérateur + . prefix = &#39;Hello&#39; suffix = &#39;World&#39; print(prefix + suffix) print(prefix + &#39; &#39; + suffix + &quot; !&quot;) . Nous pouvons mesurer la taille d&#39;une string avec la fonction built-in : len. Il existe aussi de nombreuses fonctions attachées aux string, en voici quelques exemple : . name = &quot;Jane Smith&quot; # Find the length of a string with the built-in len function print(len(name)) # Print the string converted to lowercase print(name.lower()) # Print the string converted to uppercase print(name.upper()) # Split string into a list print(name.split(&#39; &#39;)) # Print the original string print(name) . Exercice 5 : . 1) Étant donné les variables x et y, utilisez le formatage de chaîne pour afficher les valeurs de x et y et leur somme. Par exemple, si x = 5 et y = 3, votre relevé doit afficher 5 + 3 = 8. | 2) Réécrivez les chaînes suivantes en utilisant des guillemets simples au lieu de guillemets doubles. Utilisez les séquences d&#39;échappement selon vos besoins : | . &quot;Hi! I&#39;m Eli.&quot; &quot;The title of the book was &quot;Good Omens &quot;.&quot; &quot;Hi! I &#39;m Sebastien.&quot; . 3) Utilisez des séquences d&#39;échappement pour écrire une chaîne qui représente les lettres a, b et c séparées par des tabulations. . | 4) Utilisez des séquences d&#39;échappement pour écrire une chaîne contenant le texte ci-dessous (avec les sauts de ligne) à l&#39;intérieur de guillemets simples ou doubles : . | . Title : Hello World ! Year : 2021 . 5) Étant donné un nom de variable contenant une chaîne, écrivez une instruction print qui affiche le nom et le nombre de caractères qu&#39;il contient. Par exemple, si name = &quot;John&quot;, votre relevé doit afficher : John&#39;s name has 4 letters.. . | 6) Que génère la séquence d&#39;instructions suivante : . | . name = &quot;John Smith&quot; print(name.lower()) print(name) . Pourquoi la sortie de la deuxième ligne n&#39;est-elle pas en minuscule ? .",
            "url": "https://axi-technologies.github.io/AXI-Fastpages/python/chapter/1/lesson/2/",
            "relUrl": "/python/chapter/1/lesson/2/",
            "date": " • Jan 2, 2022"
        }
        
    
  
    
        ,"post9": {
            "title": "Introduction 1 : Création, exécution et installation",
            "content": "1. Python 2 vs Python 3 . Python a récemment subi un changement de version majeur de 2 à 3. Nous utiliserons Python 3. Python 2 est encore largement utilisé, et bien que Python 3 ne soit pas entièrement rétrocompatible, les deux versions sont très similaires – donc si jamais vous rencontrez du code Python 2, vous devriez le trouver assez familier. . 2. L&#39;interpr&#233;teur Python . La saisie de la commande python (sans aucun paramètre) lancera l&#39;interpréteur Python. Il s&#39;agit d&#39;une console de texte dans laquelle vous pouvez entrer les commandes Python une par une - elles seront interprétées à la volée. . python . Résultat de la commande : . Python 3.2.3 (default, Oct 19 2012, 20:10:41) [GCC 4.6.3] on linux2 Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information. &gt;&gt;&gt; . print(&#39;hello&#39;) . 3. Cr&#233;er et ex&#233;cuter un fichier python . Les fichier python doivent avoir l&#39;extension : .py pour pouvoir être reconnu et interprété par python. Créez un fichier Hello World python avec la commande bash suivante (ou directement sur VSCode) : . touch hello_world.py . Voici le contenu du fichier : . print(&#39;Hello World&#39;) . Executez le fichier : . &gt; python3 hello_world.py Hello World . 4. Installer des paquets . Installer pip : . sudo apt install python3-pip . Installer des paquet python avec pip : . pip install &lt;package-name&gt; .",
            "url": "https://axi-technologies.github.io/AXI-Fastpages/python-intro-gen/chapter/1/lesson/1/",
            "relUrl": "/python-intro-gen/chapter/1/lesson/1/",
            "date": " • Jan 2, 2022"
        }
        
    
  
    
        ,"post10": {
            "title": "Example Post",
            "content": "When writing a blog post with Microsoft Word – the filename becomes the title. In this case the file name is “2020-01-01-Microsoft-Word-Example-Post.docx”. . There is minimal support for Word documents in fastpages compared to Jupyter notebooks. Some known limitations: . alt text in Word documents are not yet supported by fastpages, and will break links to images. . | You can only specify front matter for Word documents globally. See the README for more details. . | . For greater control over the content produced from Word documents, you will need to convert Word to markdown files manually. You can follow the steps in this blog post, which walk you through how to use pandoc to do the conversion. Note: If you wish to customize your Word generated blog post in markdown, make sure you delete your Word document from the _word directory so your markdown file doesn’t get overwritten! . If your primary method of writing blog posts is Word documents, and you plan on always manually editing Word generated markdown files, you are probably better off using fast_template instead of fastpages. . The material below is a reproduction of this blog post, and serves as an illustrative example. . Maintaining a healthy open source project can entail a huge amount of toil. Popular projects often have orders of magnitude more users and episodic contributors opening issues and PRs than core maintainers capable of handling these issues. . Consider this graphic prepared by the NumFOCUS foundation showing the number of maintainers for three widely used scientific computing projects: . . We can see that across these three projects, there is a very low ratio maintainers to users. Fixing this problem is not an easy task and likely requires innovative solutions to address the economics as well as tools. . Due to its recent momentum and popularity, Kubeflow suffers from a similar fate as illustrated by the growth of new issues opened: . . Source: “TensorFlow World 2019, Automating Your Developer Workflow With ML” . Coincidentally, while building out end to end machine learning examples for Kubeflow, we built two examples using publicly available GitHub data: GitHub Issue Summarization and Code Search. While these tutorials were useful for demonstrating components of Kubeflow, we realized that we could take this a step further and build concrete data products that reduce toil for maintainers. . This is why we started the project kubeflow/code-intelligence, with the goals of increasing project velocity and health using data driven tools. Below are two projects we are currently experimenting with : . Issue Label Bot: This is a bot that automatically labels GitHub issues using Machine Learning. This bot is a GitHub App that was originally built for Kubeflow but is now also used by several large open source projects. The current version of this bot only applies a very limited set of labels, however we are currently A/B testing new models that allow personalized labels. Here is a blog post discussing this project in more detail. . | Issue Triage GitHub Action: to compliment the Issue Label Bot, we created a GitHub Action that automatically adds / removes Issues to the Kubeflow project board tracking issues needing triage. . | Together these projects allow us to reduce the toil of triaging issues. The GitHub Action makes it much easier for the Kubeflow maintainers to track issues needing triage. With the label bot we have taken the first steps in using ML to replace human intervention. We plan on using features extracted by ML to automate more steps in the triage process to further reduce toil. . Building Solutions with GitHub Actions . One of the premises of Kubeflow is that a barrier to building data driven, ML powered solutions is getting models into production and integrated into a solution. In the case of building models to improve OSS project health, that often means integrating with GitHub where the project is hosted. . We are really excited by GitHub’s newly released feature GitHub Actions because we think it will make integrating ML with GitHub much easier. . For simple scripts, like the issue triage script, GitHub actions make it easy to automate executing the script in response to GitHub events without having to build and host a GitHub app. . To automate adding/removing issues needing triage to a Kanban board we wrote a simple python script that interfaces with GitHub’s GraphQL API to modify issues. . As we continue to iterate on ML Models to further reduce toil, GitHub Actions will make it easy to leverage Kubeflow to put our models into production faster. A number of prebuilt GitHub Actions make it easy to create Kubernetes resources in response to GitHub events. For example, we have created GitHub Actions to launch Argo Workflows. This means once we have a Kubernetes job or workflow to perform inference we can easily integrate the model with GitHub and have the full power of Kubeflow and Kubernetes (eg. GPUs). We expect this will allow us to iterate much faster compared to building and maintaining GitHub Apps. . Call To Action . We have a lot more work to do in order to achieve our goal of reducing the amount of toil involved in maintaining OSS projects. If your interested in helping out here’s a couple of issues to get started: . Help us create reports that pull and visualize key performance indicators (KPI). https://github.com/kubeflow/code-intelligence/issues/71 . We have defined our KPI here: issue #19 | . | Combine repo specific and non-repo specific label predictions: https://github.com/kubeflow/code-intelligence/issues/70 . | . In addition to the aforementioned issues we welcome contributions for these other issues in our repo. .",
            "url": "https://axi-technologies.github.io/AXI-Fastpages/2020/01/01/Example-Post.html",
            "relUrl": "/2020/01/01/Example-Post.html",
            "date": " • Jan 1, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "Ce site est la propriété d’AXI Technologies SAS 1. . AXI Technologies : Notre ambition, révolutionner l’éducation en proposant un plateforme, un assistant boosté à l’intelligence artificielle et une pédagogie innovante ! &#8617; . |",
          "url": "https://axi-technologies.github.io/AXI-Fastpages/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://axi-technologies.github.io/AXI-Fastpages/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}